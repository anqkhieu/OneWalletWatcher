"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.subscribeToKeyExchangeStream = exports.parseGroupKeys = exports.getKeyExchangeStreamId = exports.isKeyExchangeStream = exports.ValidationError = void 0;
const streamr_client_protocol_1 = require("streamr-client-protocol");
const Encryption_1 = require("./Encryption");
const KEY_EXCHANGE_STREAM_PREFIX = 'SYSTEM/keyexchange';
exports.ValidationError = streamr_client_protocol_1.Errors.ValidationError;
function isKeyExchangeStream(id = '') {
    return id.startsWith(KEY_EXCHANGE_STREAM_PREFIX);
}
exports.isKeyExchangeStream = isKeyExchangeStream;
function getKeyExchangeStreamId(address) {
    if (isKeyExchangeStream(address)) {
        return address; // prevent ever double-handling
    }
    return `${KEY_EXCHANGE_STREAM_PREFIX}/${address.toLowerCase()}`;
}
exports.getKeyExchangeStreamId = getKeyExchangeStreamId;
function parseGroupKeys(groupKeys = {}) {
    return new Map(Object.entries(groupKeys || {}).map(([key, value]) => {
        if (!value || !key) {
            return null;
        }
        return [key, Encryption_1.GroupKey.from(value)];
    }).filter(Boolean));
}
exports.parseGroupKeys = parseGroupKeys;
async function subscribeToKeyExchangeStream(client, onKeyExchangeMessage) {
    const { options } = client;
    if ((!options.auth.privateKey && !options.auth.ethereum) || !options.keyExchange) {
        return Promise.resolve();
    }
    await client.session.getSessionToken(); // trigger auth errors if any
    // subscribing to own keyexchange stream
    const publisherId = await client.getUserId();
    const streamId = getKeyExchangeStreamId(publisherId);
    const sub = await client.subscribe(streamId, onKeyExchangeMessage);
    sub.on('error', () => { }); // errors should not shut down subscription
    return sub;
}
exports.subscribeToKeyExchangeStream = subscribeToKeyExchangeStream;
//# sourceMappingURL=KeyExchangeUtils.js.map