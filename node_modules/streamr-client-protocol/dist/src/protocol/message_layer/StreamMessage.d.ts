import { SPID } from '../../utils/SPID';
import MessageRef from './MessageRef';
import MessageID from './MessageID';
import EncryptedGroupKey from './EncryptedGroupKey';
import { Serializer } from '../../Serializer';
export declare enum StreamMessageType {
    MESSAGE = 27,
    GROUP_KEY_REQUEST = 28,
    GROUP_KEY_RESPONSE = 29,
    GROUP_KEY_ANNOUNCE = 30,
    GROUP_KEY_ERROR_RESPONSE = 31
}
export declare enum ContentType {
    JSON = 0
}
export declare enum SignatureType {
    NONE = 0,
    ETH_LEGACY = 1,
    ETH = 2
}
export declare enum EncryptionType {
    NONE = 0,
    RSA = 1,
    AES = 2
}
export declare type StreamMessageOptions<T> = {
    messageId: MessageID;
    prevMsgRef?: MessageRef | null;
    content: T | string;
    messageType?: StreamMessageType;
    contentType?: ContentType;
    encryptionType?: EncryptionType;
    groupKeyId?: string | null;
    newGroupKey?: EncryptedGroupKey | null;
    signatureType?: SignatureType;
    signature?: string | null;
};
export interface ObjectType<T> {
    streamId: string;
    streamPartition: number;
    timestamp: number;
    sequenceNumber: number;
    publisherId: string;
    msgChainId: string;
    messageType: StreamMessageType;
    contentType: ContentType;
    encryptionType: EncryptionType;
    groupKeyId: string | null;
    content: string | T;
    signatureType: SignatureType;
    signature: string | null;
}
/**
 * Any object that contains a toStreamMessage interface.
 * e.g. GroupKeyMessage
 */
export declare type StreamMessageContainer<T = unknown> = {
    toStreamMessage: (messageId: MessageID, prevMsgRef: MessageRef | null) => StreamMessage<T>;
};
/**
 * Unsigned StreamMessage.
 */
export declare type StreamMessageUnsigned<T> = StreamMessage<T> & {
    signatureType: SignatureType.NONE;
    signature: '' | null;
};
/**
 * Signed StreamMessage.
 */
export declare type StreamMessageSigned<T> = StreamMessage<T> & {
    signatureType: SignatureType.ETH | SignatureType.ETH_LEGACY;
    signature: string;
};
/**
 *  Encrypted StreamMessage.
 */
export declare type StreamMessageEncrypted<T> = StreamMessage<T> & {
    encryptionType: EncryptionType.RSA | EncryptionType.AES;
    groupKeyId: string;
    parsedContent: never;
};
/**
 * Unencrypted StreamMessage.
 */
export declare type StreamMessageUnencrypted<T> = StreamMessage<T> & {
    encryptionType: EncryptionType.NONE;
};
export default class StreamMessage<T = unknown> {
    static LATEST_VERSION: number;
    static MESSAGE_TYPES: typeof StreamMessageType;
    static VALID_MESSAGE_TYPES: Set<string | StreamMessageType>;
    static CONTENT_TYPES: typeof ContentType;
    static VALID_CONTENT_TYPES: Set<string | ContentType.JSON>;
    static SIGNATURE_TYPES: typeof SignatureType;
    static VALID_SIGNATURE_TYPES: Set<string | SignatureType>;
    static ENCRYPTION_TYPES: typeof EncryptionType;
    static VALID_ENCRYPTIONS: Set<string | EncryptionType>;
    messageId: MessageID;
    prevMsgRef: MessageRef | null;
    messageType: StreamMessageType;
    contentType: ContentType;
    encryptionType: EncryptionType;
    groupKeyId: string | null;
    newGroupKey: EncryptedGroupKey | null;
    signatureType: SignatureType;
    signature: string | null;
    parsedContent?: T;
    serializedContent: string;
    spid: SPID;
    /**
     * Create a new StreamMessage identical to the passed-in streamMessage.
     */
    clone(): StreamMessage<T>;
    constructor({ messageId, prevMsgRef, content, messageType, contentType, encryptionType, groupKeyId, newGroupKey, signatureType, signature, }: StreamMessageOptions<T>);
    getStreamId(): string;
    getStreamPartition(): number;
    getSPID(): SPID;
    getTimestamp(): number;
    getSequenceNumber(): number;
    getPublisherId(): string;
    getMsgChainId(): string;
    getMessageRef(): MessageRef;
    getPreviousMessageRef(): MessageRef | null;
    getMessageID(): MessageID;
    getSerializedContent(): string;
    /**
     * Lazily parses the content to JSON
     */
    getParsedContent(): T;
    getContent(): string;
    getContent(parsedContent: false): string;
    getContent(parsedContent: true): T;
    getNewGroupKey(): EncryptedGroupKey | null;
    isByeMessage(): boolean;
    /**
     * Gets appropriate payload to sign for this signature type.
     * Optionally sets new signature type at same time, which allows typesafe
     * signing without messages needing to be in a partially signed state.
     * e.g.
     * ```
     * const signedMessage: StreamMessageSigned = Object.assign(unsigedMessage, {
     *     signature: unsigedMessage.getPayloadToSign(SignatureType.ETH),
     * })
     * ```
     */
    getPayloadToSign(newSignatureType?: SignatureType): string;
    static registerSerializer(version: number, serializer: Serializer<StreamMessage<unknown>>): void;
    static unregisterSerializer(version: number): void;
    static getSerializer(version: number): Serializer<StreamMessage<unknown>>;
    static getSupportedVersions(): number[];
    serialize(version?: number): string;
    /**
     * Takes a serialized representation (array or string) of a message, and returns a StreamMessage instance.
     */
    static deserialize(msg: any[] | string): StreamMessage;
    static validateMessageType(messageType: StreamMessageType): void;
    static validateContentType(contentType: ContentType): void;
    static validateEncryptionType(encryptionType: EncryptionType): void;
    static validateSignatureType(signatureType: SignatureType): void;
    static versionSupportsEncryption(streamMessageVersion: number): boolean;
    static validateSequence({ messageId, prevMsgRef }: {
        messageId: MessageID;
        prevMsgRef?: MessageRef | null;
    }): void;
    static isUnsigned<T = unknown>(msg: StreamMessage<T>): msg is StreamMessageUnsigned<T>;
    static isSigned<T = unknown>(msg: StreamMessage<T>): msg is StreamMessageSigned<T>;
    static isEncrypted<T = unknown>(msg: StreamMessage<T>): msg is StreamMessageEncrypted<T>;
    static isUnencrypted<T = unknown>(msg: StreamMessage<T>): msg is StreamMessageUnencrypted<T>;
    static isStreamMessageContainer<T = unknown>(content: any): content is StreamMessageContainer<T>;
    toObject(): ObjectType<T>;
}
