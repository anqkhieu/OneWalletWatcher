"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.StreamrClient = void 0;
/**
 * @see {@link StreamrClient.StreamrClient}
 * @module StreamrClient
 */
const eventemitter3_1 = __importDefault(require("eventemitter3"));
const streamr_client_protocol_1 = require("streamr-client-protocol");
const node_fetch_1 = __importDefault(require("node-fetch"));
const utils_1 = require("./utils");
const log_1 = require("./utils/log");
const utils_2 = require("./stream/utils");
const Config_1 = __importDefault(require("./Config"));
const Ethereum_1 = __importDefault(require("./Ethereum"));
const Session_1 = __importDefault(require("./Session"));
const Connection_1 = __importStar(require("./Connection"));
const publish_1 = __importDefault(require("./publish"));
const subscribe_1 = require("./subscribe");
const user_1 = require("./user");
const StreamEndpoints_1 = require("./rest/StreamEndpoints");
const LoginEndpoints_1 = require("./rest/LoginEndpoints");
const DataUnion_1 = require("./dataunion/DataUnion");
const address_1 = require("@ethersproject/address");
const contracts_1 = require("@ethersproject/contracts");
const Contracts_1 = __importDefault(require("./dataunion/Contracts"));
const balanceOfAbi = [{
        name: 'balanceOf',
        inputs: [{ type: 'address' }],
        outputs: [{ type: 'uint256' }],
        constant: true,
        payable: false,
        stateMutability: 'view',
        type: 'function'
    }];
/**
 * Wrap connection message events with message parsing.
 */
class StreamrConnection extends Connection_1.default {
    // TODO define args type when we convert Connection class to TypeScript
    constructor(options, debug) {
        super(options, debug);
        this.on('message', this.onConnectionMessage);
    }
    // eslint-disable-next-line class-methods-use-this
    parse(messageEvent) {
        return streamr_client_protocol_1.ControlLayer.ControlMessage.deserialize(messageEvent.data);
    }
    onConnectionMessage(messageEvent) {
        let controlMessage;
        try {
            controlMessage = this.parse(messageEvent);
        }
        catch (err) {
            this.debug('(%o) << %o', this.getState(), messageEvent && messageEvent.data);
            this.debug('deserialize error', err);
            this.emit('error', err);
            return;
        }
        if (!controlMessage) {
            return;
        }
        this.debug('(%o) << %o', this.getState(), controlMessage);
        this.emit(controlMessage.type, controlMessage);
    }
}
class StreamrCached {
    constructor(client) {
        this.client = client;
        const cacheOptions = client.options.cache;
        this.getStream = utils_1.CacheAsyncFn(client.getStream.bind(client), {
            ...cacheOptions,
            cacheKey([maybeStreamId]) {
                const { streamId } = utils_2.validateOptions(maybeStreamId);
                return streamId;
            }
        });
        this.getUserInfo = utils_1.CacheAsyncFn(client.getUserInfo.bind(client), cacheOptions);
        this.isStreamPublisher = utils_1.CacheAsyncFn(client.isStreamPublisher.bind(client), {
            ...cacheOptions,
            cacheKey([maybeStreamId, ethAddress]) {
                const { streamId } = utils_2.validateOptions(maybeStreamId);
                return `${streamId}|${ethAddress}`;
            }
        });
        this.isStreamSubscriber = utils_1.CacheAsyncFn(client.isStreamSubscriber.bind(client), {
            ...cacheOptions,
            cacheKey([maybeStreamId, ethAddress]) {
                const { streamId } = utils_2.validateOptions(maybeStreamId);
                return `${streamId}|${ethAddress}`;
            }
        });
        this.getUserId = utils_1.CacheAsyncFn(client.getUserId.bind(client), cacheOptions);
    }
    clearStream(streamId) {
        this.getStream.clear();
        if (streamId != null) {
            this.isStreamPublisher.clearMatching((s) => s.startsWith(streamId));
            this.isStreamSubscriber.clearMatching((s) => s.startsWith(streamId));
        }
        else {
            this.isStreamPublisher.clear();
            this.isStreamSubscriber.clear();
        }
    }
    clearUser() {
        this.getUserInfo.clear();
        this.getUserId.clear();
    }
    clear() {
        this.clearUser();
        this.clearStream();
    }
}
let uid = process.pid != null
    // Use process id in node uid.
    ? `${process.pid}`
    // Fall back to `uuid()` later (see the constructor). Doing it here will break browser projects
    // that utilize server-side rendering (no `window` while build's target is `web`).
    : '';
/**
 * Take prototype functions from srcInstance and attach them to targetInstance while keeping them bound to srcInstance.
 */
function Plugin(targetInstance, srcInstance) {
    Object.getOwnPropertyNames(srcInstance.constructor.prototype).forEach((name) => {
        const value = srcInstance.constructor.prototype[name];
        if (typeof value !== 'function') {
            return;
        }
        // eslint-disable-next-line no-param-reassign
        targetInstance[name] = srcInstance[name].bind(srcInstance);
    });
    return srcInstance;
}
/**
 * @category Important
 */
class StreamrClient extends eventemitter3_1.default {
    // TODO annotate connection parameter as internal parameter if possible?
    constructor(options = {}, connection) {
        super();
        uid = uid || `${utils_1.uuid().slice(-4)}${utils_1.uuid().slice(0, 4)}`;
        this.id = utils_1.counterId(`${this.constructor.name}-${uid}${options.id || ''}`);
        this.debug = log_1.Debug(this.id);
        this.options = Config_1.default(options);
        this.debug('new StreamrClient %s: %o', this.id, {
            version: process.env.version,
            GIT_VERSION: process.env.GIT_VERSION,
            GIT_COMMITHASH: process.env.GIT_COMMITHASH,
            GIT_BRANCH: process.env.GIT_BRANCH,
        });
        // bind event handlers
        this.onConnectionConnected = this.onConnectionConnected.bind(this);
        this.onConnectionDisconnected = this.onConnectionDisconnected.bind(this);
        this.onConnectionDone = utils_1.pOne(this.onConnectionDone.bind(this));
        this._onError = this._onError.bind(this);
        this.onConnectionError = this.onConnectionError.bind(this);
        this.getErrorEmitter = this.getErrorEmitter.bind(this);
        this.on('error', this._onError); // attach before creating sub-components incase they fire error events
        this.session = new Session_1.default(this, this.options.auth);
        this.connection = connection || new StreamrConnection(this.options, this.debug);
        this.connection
            .on('connected', this.onConnectionConnected)
            .on('disconnected', this.onConnectionDisconnected)
            .on('done', this.onConnectionDone)
            .on('error', this.onConnectionError);
        this.ethereum = new Ethereum_1.default(this);
        this.publisher = new publish_1.default(this);
        this.subscriber = new subscribe_1.Subscriber(this);
        Plugin(this, new StreamEndpoints_1.StreamEndpoints(this));
        Plugin(this, new LoginEndpoints_1.LoginEndpoints(this));
        this.cached = new StreamrCached(this);
    }
    enableDebugLogging(prefix = 'Streamr*') {
        log_1.Debug.enable(prefix);
    }
    disableDebugLogging() {
        log_1.Debug.disable();
    }
    /** @internal */
    async onConnectionConnected() {
        this.debug('Connected!');
        this.emit('connected');
    }
    /** @internal */
    async onConnectionDisconnected() {
        this.debug('Disconnected.');
        this.emit('disconnected');
    }
    /** @internal */
    onConnectionError(err) {
        this.emit('error', new Connection_1.ConnectionError(err));
    }
    /** @internal */
    onConnectionDone() {
        this.stop().catch(() => {
            // ignore
        });
    }
    async stop() {
        this.cached.clear();
        await Promise.allSettled([
            this.publisher.stop().catch(() => { }),
            this.subscriber.stop().catch(() => { }),
            this.session.logout().catch(() => { })
        ]);
        this.cached.clear();
    }
    /** @internal */
    getErrorEmitter(source) {
        return (err) => {
            if (!(err instanceof Connection_1.ConnectionError || err.reason instanceof Connection_1.ConnectionError)) {
                // emit non-connection errors
                this.emit('error', err);
            }
            else {
                source.debug('error', err);
            }
        };
    }
    /** @internal */
    _onError(err, ...args) {
        // @ts-expect-error
        this.onError(err, ...args);
    }
    /** @internal */
    async send(request) {
        return this.connection.send(request);
    }
    /**
     * Override to control output
     */
    onError(error) {
        console.error(error);
    }
    isConnected() {
        return this.connection.isConnected();
    }
    isConnecting() {
        return this.connection.isConnecting();
    }
    isDisconnecting() {
        return this.connection.isDisconnecting();
    }
    isDisconnected() {
        return this.connection.isDisconnected();
    }
    /**
     * @category Important
     */
    async connect() {
        return this.connection.connect();
    }
    async nextConnection() {
        return this.connection.nextConnection();
    }
    /**
     * @category Important
     */
    async disconnect() {
        await this.connection.disconnect();
        await this.stop();
    }
    getSubscriptions() {
        return this.subscriber.getAll();
    }
    getSubscription(definition) {
        return this.subscriber.get(definition);
    }
    async ensureConnected() {
        return this.connect();
    }
    async ensureDisconnected() {
        return this.disconnect();
    }
    logout() {
        return this.session.logout();
    }
    /**
     * @category Important
     */
    async publish(streamObjectOrId, content, timestamp, partitionKey) {
        return this.publisher.publish(streamObjectOrId, content, timestamp, partitionKey);
    }
    async getUserId() {
        return user_1.getUserId(this);
    }
    async setNextGroupKey(streamId, newKey) {
        return this.publisher.setNextGroupKey(streamId, newKey);
    }
    async rotateGroupKey(streamId) {
        return this.publisher.rotateGroupKey(streamId);
    }
    async rekey(streamId) {
        return this.publisher.rekey(streamId);
    }
    /**
     * @category Important
     */
    async subscribe(opts, onMessage) {
        let subTask;
        let sub;
        const hasResend = !!(opts.resend || opts.from || opts.to || opts.last);
        const onEnd = (err) => {
            if (sub && typeof onMessage === 'function') {
                sub.off('message', onMessage);
            }
            if (err) {
                throw err;
            }
        };
        if (hasResend) {
            subTask = this.subscriber.resendSubscribe(opts, onEnd);
        }
        else {
            subTask = this.subscriber.subscribe(opts, onEnd);
        }
        if (typeof onMessage === 'function') {
            Promise.resolve(subTask).then(async (s) => {
                sub = s;
                sub.on('message', onMessage);
                for await (const msg of sub) {
                    sub.emit('message', msg.getParsedContent(), msg);
                }
                return sub;
            }).catch((err) => {
                this.emit('error', err);
            });
        }
        return subTask;
    }
    /**
     * @category Important
     */
    async unsubscribe(subscription) {
        await this.subscriber.unsubscribe(subscription);
    }
    /**
     * @category Important
     */
    async resend(opts, onMessage) {
        const task = this.subscriber.resend(opts);
        if (typeof onMessage !== 'function') {
            return task;
        }
        Promise.resolve(task).then(async (sub) => {
            for await (const msg of sub) {
                await onMessage(msg.getParsedContent(), msg);
            }
            return sub;
        }).catch((err) => {
            this.emit('error', err);
        });
        return task;
    }
    enableAutoConnect(autoConnect) {
        return this.connection.enableAutoConnect(autoConnect);
    }
    enableAutoDisconnect(autoDisconnect) {
        return this.connection.enableAutoDisconnect(autoDisconnect);
    }
    async getAddress() {
        return this.ethereum.getAddress();
    }
    async getPublisherId() {
        return this.getAddress();
    }
    /**
     * True if authenticated with private key/ethereum provider
     */
    canEncrypt() {
        return this.ethereum.canEncrypt();
    }
    /**
     * Get token balance in "wei" (10^-18 parts) for given address
     */
    async getTokenBalance(address) {
        const { tokenAddress } = this.options;
        const addr = address_1.getAddress(address);
        const provider = this.ethereum.getMainnetProvider();
        const token = new contracts_1.Contract(tokenAddress, balanceOfAbi, provider);
        return token.balanceOf(addr);
    }
    /**
     * Get token balance in "wei" (10^-18 parts) for given address in sidechain
     */
    async getSidechainTokenBalance(address) {
        const { tokenSidechainAddress } = this.options;
        const addr = address_1.getAddress(address);
        const provider = this.ethereum.getSidechainProvider();
        const token = new contracts_1.Contract(tokenSidechainAddress, balanceOfAbi, provider);
        return token.balanceOf(addr);
    }
    getDataUnion(contractAddress) {
        return DataUnion_1.DataUnion._fromContractAddress(contractAddress, this); // eslint-disable-line no-underscore-dangle
    }
    async safeGetDataUnion(contractAddress) {
        const du = DataUnion_1.DataUnion._fromContractAddress(contractAddress, this); // eslint-disable-line no-underscore-dangle
        const version = await du.getVersion();
        if (version === 0) {
            throw new Error(`${contractAddress} is not a Data Union!`);
        }
        else if (version === 1) {
            throw new Error(`${contractAddress} is an old Data Union, please use StreamrClient 4.x or earlier!`);
        }
        else if (version === 2) {
            return du;
        }
        throw new Error(`${contractAddress} is an unknown Data Union version "${version}"`);
    }
    async deployDataUnion(options) {
        return DataUnion_1.DataUnion._deploy(options, this); // eslint-disable-line no-underscore-dangle
    }
    async setBinanceDepositAddress(binanceRecipient) {
        return DataUnion_1.DataUnion._setBinanceDepositAddress(binanceRecipient, this); // eslint-disable-line no-underscore-dangle
    }
    async setBinanceDepositAddressFromSignature(from, binanceRecipient, signature) {
        return DataUnion_1.DataUnion._setBinanceDepositAddressFromSignature(from, binanceRecipient, signature, this); // eslint-disable-line no-underscore-dangle
    }
    // TODO: define returned object's type
    async setBinanceDepositAddressViaWithdrawServer(from, binanceRecipient, signature) {
        const url = utils_1.getEndpointUrl(this.options.withdrawServerUrl, 'binanceAdapterSetRecipient');
        const body = {
            memberAddress: from,
            binanceRecipientAddress: binanceRecipient,
            signature
        };
        return node_fetch_1.default(url, {
            method: 'POST',
            body: JSON.stringify(body),
            headers: { 'Content-Type': 'application/json' }
        });
    }
    async getBinanceDepositAddress(userAddress) {
        return DataUnion_1.DataUnion._getBinanceDepositAddress(userAddress, this); // eslint-disable-line no-underscore-dangle
    }
    async signSetBinanceRecipient(recipientAddress) {
        const to = address_1.getAddress(recipientAddress); // throws if bad address
        const signer = this.ethereum.getSigner();
        return DataUnion_1.DataUnion._createSetBinanceRecipientSignature(to, signer, new Contracts_1.default(this)); // eslint-disable-line no-underscore-dangle
    }
    /** @internal */
    _getDataUnionFromName({ dataUnionName, deployerAddress }) {
        return DataUnion_1.DataUnion._fromName({
            dataUnionName,
            deployerAddress
        }, this);
    }
    /**
     * @category Important
     */
    static generateEthereumAccount() {
        return Ethereum_1.default.generateEthereumAccount();
    }
}
exports.StreamrClient = StreamrClient;
//# sourceMappingURL=StreamrClient.js.map