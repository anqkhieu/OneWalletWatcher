/**
 * Copyright (c) 2020, Peculiar Ventures, All rights reserved.
 */

import * as crypto from 'crypto';
import * as core from 'webcrypto-core';
import { __awaiter } from 'tslib';
import * as fs from 'fs';
import * as mkdirp from 'mkdirp';
import * as path from 'path';
import { Convert } from 'pvtsutils';
import * as native from '../build/Release/nodessl.node';
import { AsnParser } from '@peculiar/asn1-schema';

const FILE_EXT = ".jkey";
class CryptoKeyStorage$1 {
    constructor(crypto, directory) {
        this.directory = "";
        this.items = new WeakMap();
        this.crypto = crypto;
        this.directory = path.normalize(directory);
        if (!fs.existsSync(this.directory)) {
            mkdirp.sync(this.directory);
        }
    }
    getItem(index, algorithm, extractable, keyUsages) {
        return __awaiter(this, void 0, void 0, function* () {
            const fileKey = this.readFile(this.getFilePath(index));
            if (!fileKey) {
                throw new core.OperationError("Cannot get key form file");
            }
            return this.crypto.subtle.importKey("jwk", fileKey.jwk, algorithm !== null && algorithm !== void 0 ? algorithm : fileKey.algorithm, extractable !== null && extractable !== void 0 ? extractable : fileKey.extractable, keyUsages !== null && keyUsages !== void 0 ? keyUsages : fileKey.usages);
        });
    }
    keys() {
        return __awaiter(this, void 0, void 0, function* () {
            const items = fs.readdirSync(this.directory);
            const res = [];
            items.forEach((item) => {
                if (item !== "." && item !== "..") {
                    const file = path.join(this.directory, item);
                    const stat = fs.statSync(file);
                    if (stat.isFile()) {
                        const key = this.readFile(file);
                        if (key) {
                            res.push(path.parse(item).name);
                        }
                    }
                }
            });
            return res;
        });
    }
    indexOf(item) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.items.get(item) || null;
        });
    }
    setItem(item, id) {
        return __awaiter(this, void 0, void 0, function* () {
            const subtle = this.crypto.subtle;
            const provider = subtle.getProvider(item.algorithm.name);
            const jwk = yield provider.onExportKey("jwk", item);
            const keyAlgorithm = item.algorithm;
            const algorithm = { name: keyAlgorithm.name };
            if (keyAlgorithm.hash) {
                algorithm.hash = keyAlgorithm.hash;
            }
            const name = id || Convert.ToHex(this.crypto.getRandomValues(new Uint8Array(10)));
            this.writeFile(name, {
                algorithm,
                extractable: item.extractable,
                usages: item.usages,
                type: item.type,
                jwk,
            });
            this.items.set(item, name);
            return name;
        });
    }
    hasItem(item) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.items.has(item);
        });
    }
    clear() {
        return __awaiter(this, void 0, void 0, function* () {
            const keys = yield this.keys();
            for (const key of keys) {
                this.removeItem(key);
            }
        });
    }
    removeItem(index) {
        return __awaiter(this, void 0, void 0, function* () {
            const fileName = this.getFilePath(index);
            const keyFile = this.readFile(fileName);
            if (keyFile) {
                fs.unlinkSync(fileName);
            }
        });
    }
    readFile(file) {
        const json = fs.readFileSync(file, "utf8");
        let parsedJson;
        try {
            parsedJson = JSON.parse(json);
        }
        catch (e) {
            return null;
        }
        if (parsedJson.algorithm && parsedJson.type && parsedJson.usages && parsedJson.jwk) {
            return parsedJson;
        }
        return null;
    }
    writeFile(name, key) {
        const json = JSON.stringify(key);
        fs.writeFileSync(this.getFilePath(name), json, {
            encoding: "utf8",
            flag: "w",
        });
    }
    getFilePath(name) {
        return path.join(this.directory, `${name}${FILE_EXT}`);
    }
}

class CryptoKey extends core.CryptoKey {
    constructor() {
        super(...arguments);
        this.algorithm = { name: "" };
        this.extractable = false;
        this.type = "secret";
        this.usages = [];
    }
}

class SymmetricKey extends CryptoKey {
    constructor() {
        super(...arguments);
        this.type = "secret";
    }
}

class AsymmetricKey extends CryptoKey {
}

const keyStorage = new WeakMap();
class CryptoKeyStorage {
    static getItem(key) {
        const res = keyStorage.get(key);
        if (!res) {
            throw new core.OperationError("Cannot get CryptoKey from secure storage");
        }
        return res;
    }
    static setItem(value) {
        const key = core.CryptoKey.create(value.algorithm, value.type, value.extractable, value.usages);
        Object.freeze(key);
        keyStorage.set(key, value);
        return key;
    }
}

class AesCryptoKey extends SymmetricKey {
}

class AesCrypto {
    static generateKey(algorithm, extractable, keyUsages) {
        return new Promise((resolve, reject) => {
            native.AesKey.generate(algorithm.length / 8, (err, key) => {
                if (err) {
                    reject(err);
                }
                else {
                    const secret = AesCryptoKey.create(algorithm, "secret", extractable, keyUsages);
                    secret.native = key;
                    resolve(secret);
                }
            });
        });
    }
    static exportKey(format, key) {
        return new Promise((resolve, reject) => {
            const nativeKey = key.native;
            switch (format.toLocaleLowerCase()) {
                case "jwk":
                    const jwk = {
                        kty: "oct",
                        alg: "",
                        key_ops: key.usages,
                        k: "",
                        ext: true,
                    };
                    jwk.alg = `A${key.algorithm.length}${/-(\w+)$/.exec(key.algorithm.name)[1].toUpperCase()}`;
                    nativeKey.export((err, data) => {
                        if (err) {
                            reject(err);
                        }
                        else {
                            jwk.k = Convert.ToBase64Url(data);
                            resolve(jwk);
                        }
                    });
                    break;
                case "raw":
                    nativeKey.export((err, data) => {
                        if (err) {
                            reject(err);
                        }
                        else {
                            resolve(core.BufferSourceConverter.toArrayBuffer(data));
                        }
                    });
                    break;
                default:
                    throw new core.OperationError("format: Must be 'jwk' or 'raw'");
            }
        });
    }
    static importKey(format, keyData, algorithm, extractable, keyUsages) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                const formatLC = format.toLocaleLowerCase();
                let raw;
                switch (formatLC) {
                    case "jwk":
                        raw = Convert.FromBase64Url(keyData.k);
                        break;
                    case "raw":
                        raw = keyData;
                        break;
                    default:
                        throw new core.OperationError("format: Must be 'jwk' or 'raw'");
                }
                const keyLengthBits = raw.byteLength << 3;
                switch (keyLengthBits) {
                    case 128:
                    case 192:
                    case 256:
                        break;
                    default:
                        throw new core.OperationError("keyData: Is wrong key length");
                }
                native.AesKey.import(Buffer.from(raw), (err, key) => {
                    if (err) {
                        reject(err);
                    }
                    else {
                        const secret = AesCryptoKey.create(Object.assign(Object.assign({}, algorithm), { length: keyLengthBits }), "secret", extractable, keyUsages);
                        secret.native = key;
                        resolve(secret);
                    }
                });
            });
        });
    }
    static checkCryptoKey(key) {
        if (!(CryptoKeyStorage.getItem(key) instanceof AesCryptoKey)) {
            throw new TypeError("key: Is not a AesCryptoKey");
        }
    }
}

class AesCbcProvider extends core.AesCbcProvider {
    onGenerateKey(algorithm, extractable, keyUsages) {
        return __awaiter(this, void 0, void 0, function* () {
            const key = yield AesCrypto.generateKey({
                name: this.name,
                length: algorithm.length,
            }, extractable, keyUsages);
            return CryptoKeyStorage.setItem(key);
        });
    }
    onEncrypt(algorithm, key, data) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.internalEncrypt(algorithm, key, data, true);
        });
    }
    onDecrypt(algorithm, key, data) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.internalEncrypt(algorithm, key, data, false);
        });
    }
    onExportKey(format, key) {
        return __awaiter(this, void 0, void 0, function* () {
            return AesCrypto.exportKey(format, CryptoKeyStorage.getItem(key));
        });
    }
    onImportKey(format, keyData, algorithm, extractable, keyUsages) {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield AesCrypto.importKey(format, keyData, { name: this.name }, extractable, keyUsages);
            return CryptoKeyStorage.setItem(res);
        });
    }
    checkCryptoKey(key, keyUsage) {
        super.checkCryptoKey(key, keyUsage);
        AesCrypto.checkCryptoKey(key);
    }
    internalEncrypt(algorithm, key, data, encrypt) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                const aesKey = CryptoKeyStorage.getItem(key).native;
                const iv = Buffer.from(core.BufferSourceConverter.toArrayBuffer(algorithm.iv));
                const func = encrypt
                    ? aesKey.encrypt.bind(aesKey)
                    : aesKey.decrypt.bind(aesKey);
                const buf = Buffer.from(data);
                func("CBC", iv, buf, (err, data2) => {
                    if (err) {
                        reject(err);
                    }
                    else {
                        resolve(core.BufferSourceConverter.toArrayBuffer(data2.buffer));
                    }
                });
            });
        });
    }
}

const zero = Buffer.from([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
const rb = Buffer.from([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 135]);
const blockSize = 16;
function bitShiftLeft(buffer) {
    const shifted = Buffer.alloc(buffer.length);
    const last = buffer.length - 1;
    for (let index = 0; index < last; index++) {
        shifted[index] = buffer[index] << 1;
        if (buffer[index + 1] & 0x80) {
            shifted[index] += 0x01;
        }
    }
    shifted[last] = buffer[last] << 1;
    return shifted;
}
function xor(a, b) {
    const length = Math.min(a.length, b.length);
    const output = Buffer.alloc(length);
    for (let index = 0; index < length; index++) {
        output[index] = a[index] ^ b[index];
    }
    return output;
}
function aes(key, message) {
    const cipher = crypto.createCipheriv(`aes${key.length << 3}`, key, zero);
    const result = cipher.update(message);
    cipher.final();
    return result;
}
function getMessageBlock(message, blockIndex) {
    const block = Buffer.alloc(blockSize);
    const start = blockIndex * blockSize;
    const end = start + blockSize;
    message.copy(block, 0, start, end);
    return block;
}
function getPaddedMessageBlock(message, blockIndex) {
    const block = Buffer.alloc(blockSize);
    const start = blockIndex * blockSize;
    const end = message.length;
    block.fill(0);
    message.copy(block, 0, start, end);
    block[end - start] = 0x80;
    return block;
}
function generateSubkeys(key) {
    const l = aes(key, zero);
    let subkey1 = bitShiftLeft(l);
    if (l[0] & 0x80) {
        subkey1 = xor(subkey1, rb);
    }
    let subkey2 = bitShiftLeft(subkey1);
    if (subkey1[0] & 0x80) {
        subkey2 = xor(subkey2, rb);
    }
    return { subkey1, subkey2 };
}
function aesCmac(key, message) {
    const subkeys = generateSubkeys(key);
    let blockCount = Math.ceil(message.length / blockSize);
    let lastBlockCompleteFlag;
    let lastBlock;
    if (blockCount === 0) {
        blockCount = 1;
        lastBlockCompleteFlag = false;
    }
    else {
        lastBlockCompleteFlag = (message.length % blockSize === 0);
    }
    const lastBlockIndex = blockCount - 1;
    if (lastBlockCompleteFlag) {
        lastBlock = xor(getMessageBlock(message, lastBlockIndex), subkeys.subkey1);
    }
    else {
        lastBlock = xor(getPaddedMessageBlock(message, lastBlockIndex), subkeys.subkey2);
    }
    let x = zero;
    let y;
    for (let index = 0; index < lastBlockIndex; index++) {
        y = xor(x, getMessageBlock(message, index));
        x = aes(key, y);
    }
    y = xor(lastBlock, x);
    return aes(key, y);
}
class AesCmacProvider extends core.AesCmacProvider {
    onGenerateKey(algorithm, extractable, keyUsages) {
        return __awaiter(this, void 0, void 0, function* () {
            const key = yield AesCrypto.generateKey({
                name: this.name,
                length: algorithm.length,
            }, extractable, keyUsages);
            return CryptoKeyStorage.setItem(key);
        });
    }
    onSign(algorithm, key, data) {
        return __awaiter(this, void 0, void 0, function* () {
            const raw = yield this.onExportKey("raw", key);
            const result = aesCmac(Buffer.from(raw), Buffer.from(data));
            return new Uint8Array(result).buffer;
        });
    }
    onVerify(algorithm, key, signature, data) {
        return __awaiter(this, void 0, void 0, function* () {
            const signature2 = yield this.sign(algorithm, key, data);
            return Buffer.from(signature).compare(Buffer.from(signature2)) === 0;
        });
    }
    onExportKey(format, key) {
        return __awaiter(this, void 0, void 0, function* () {
            return AesCrypto.exportKey(format, CryptoKeyStorage.getItem(key));
        });
    }
    onImportKey(format, keyData, algorithm, extractable, keyUsages) {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield AesCrypto.importKey(format, keyData, { name: this.name }, extractable, keyUsages);
            return CryptoKeyStorage.setItem(res);
        });
    }
    checkCryptoKey(key, keyUsage) {
        super.checkCryptoKey(key, keyUsage);
        AesCrypto.checkCryptoKey(key);
    }
}

class AesCtrProvider extends core.AesCtrProvider {
    onGenerateKey(algorithm, extractable, keyUsages) {
        return __awaiter(this, void 0, void 0, function* () {
            const key = yield AesCrypto.generateKey({
                name: this.name,
                length: algorithm.length,
            }, extractable, keyUsages);
            return CryptoKeyStorage.setItem(key);
        });
    }
    onEncrypt(algorithm, key, data) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.internalEncrypt(algorithm, key, data, true);
        });
    }
    onDecrypt(algorithm, key, data) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.internalEncrypt(algorithm, key, data, false);
        });
    }
    onExportKey(format, key) {
        return __awaiter(this, void 0, void 0, function* () {
            return AesCrypto.exportKey(format, CryptoKeyStorage.getItem(key));
        });
    }
    onImportKey(format, keyData, algorithm, extractable, keyUsages) {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield AesCrypto.importKey(format, keyData, { name: this.name }, extractable, keyUsages);
            return CryptoKeyStorage.setItem(res);
        });
    }
    checkCryptoKey(key, keyUsage) {
        super.checkCryptoKey(key, keyUsage);
        AesCrypto.checkCryptoKey(key);
    }
    internalEncrypt(algorithm, key, data, encrypt) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                const aesKey = CryptoKeyStorage.getItem(key).native;
                const counter = Buffer.from(core.BufferSourceConverter.toArrayBuffer(algorithm.counter));
                const func = encrypt
                    ? aesKey.encryptCtr.bind(aesKey)
                    : aesKey.decryptCtr.bind(aesKey);
                func(Buffer.from(data), counter, algorithm.length, (err, data2) => {
                    if (err) {
                        reject(err);
                    }
                    else {
                        resolve(core.BufferSourceConverter.toArrayBuffer(data2.buffer));
                    }
                });
            });
        });
    }
}

class AesGcmProvider extends core.AesGcmProvider {
    onGenerateKey(algorithm, extractable, keyUsages) {
        return __awaiter(this, void 0, void 0, function* () {
            const key = yield AesCrypto.generateKey({
                name: this.name,
                length: algorithm.length,
            }, extractable, keyUsages);
            return CryptoKeyStorage.setItem(key);
        });
    }
    onEncrypt(algorithm, key, data) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.internalEncrypt(algorithm, key, data, true);
        });
    }
    onDecrypt(algorithm, key, data) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.internalEncrypt(algorithm, key, data, false);
        });
    }
    onExportKey(format, key) {
        return __awaiter(this, void 0, void 0, function* () {
            return AesCrypto.exportKey(format, CryptoKeyStorage.getItem(key));
        });
    }
    onImportKey(format, keyData, algorithm, extractable, keyUsages) {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield AesCrypto.importKey(format, keyData, { name: this.name }, extractable, keyUsages);
            return CryptoKeyStorage.setItem(res);
        });
    }
    checkCryptoKey(key, keyUsage) {
        super.checkCryptoKey(key, keyUsage);
        AesCrypto.checkCryptoKey(key);
    }
    internalEncrypt(algorithm, key, data, encrypt) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                const aesKey = CryptoKeyStorage.getItem(key).native;
                const iv = Buffer.from(core.BufferSourceConverter.toArrayBuffer(algorithm.iv));
                const aad = algorithm.additionalData ? Buffer.from(algorithm.additionalData) : Buffer.alloc(0);
                const tagLength = algorithm.tagLength || 128;
                const func = encrypt
                    ? aesKey.encryptGcm.bind(aesKey)
                    : aesKey.decryptGcm.bind(aesKey);
                func(iv, Buffer.from(data), aad || Buffer.alloc(0), tagLength >> 3, (err, data2) => {
                    if (err) {
                        reject(err);
                    }
                    else {
                        resolve(core.BufferSourceConverter.toArrayBuffer(data2.buffer));
                    }
                });
            });
        });
    }
}

class AesKwProvider extends core.AesKwProvider {
    onGenerateKey(algorithm, extractable, keyUsages) {
        return __awaiter(this, void 0, void 0, function* () {
            const key = yield AesCrypto.generateKey({
                name: this.name,
                length: algorithm.length,
            }, extractable, keyUsages);
            return CryptoKeyStorage.setItem(key);
        });
    }
    onEncrypt(algorithm, key, data) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.internalEncrypt(algorithm, key, data, true);
        });
    }
    onDecrypt(algorithm, key, data) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.internalEncrypt(algorithm, key, data, false);
        });
    }
    onExportKey(format, key) {
        return __awaiter(this, void 0, void 0, function* () {
            return AesCrypto.exportKey(format, CryptoKeyStorage.getItem(key));
        });
    }
    onImportKey(format, keyData, algorithm, extractable, keyUsages) {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield AesCrypto.importKey(format, keyData, { name: this.name }, extractable, keyUsages);
            return CryptoKeyStorage.setItem(res);
        });
    }
    checkCryptoKey(key, keyUsage) {
        super.checkCryptoKey(key, keyUsage);
        AesCrypto.checkCryptoKey(key);
    }
    internalEncrypt(algorithm, key, data, encrypt) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                const aesKey = CryptoKeyStorage.getItem(key).native;
                const func = encrypt
                    ? aesKey.wrapKey.bind(aesKey)
                    : aesKey.unwrapKey.bind(aesKey);
                func(Buffer.from(data), (err, data2) => {
                    if (err) {
                        reject(err);
                    }
                    else {
                        resolve(core.BufferSourceConverter.toArrayBuffer(data2));
                    }
                });
            });
        });
    }
}

class AesEcbProvider extends core.AesEcbProvider {
    onGenerateKey(algorithm, extractable, keyUsages) {
        return __awaiter(this, void 0, void 0, function* () {
            const key = yield AesCrypto.generateKey({
                name: this.name,
                length: algorithm.length,
            }, extractable, keyUsages);
            return CryptoKeyStorage.setItem(key);
        });
    }
    onEncrypt(algorithm, key, data) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.internalEncrypt(algorithm, key, data, true);
        });
    }
    onDecrypt(algorithm, key, data) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.internalEncrypt(algorithm, key, data, false);
        });
    }
    onExportKey(format, key) {
        return __awaiter(this, void 0, void 0, function* () {
            return AesCrypto.exportKey(format, CryptoKeyStorage.getItem(key));
        });
    }
    onImportKey(format, keyData, algorithm, extractable, keyUsages) {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield AesCrypto.importKey(format, keyData, { name: this.name }, extractable, keyUsages);
            return CryptoKeyStorage.setItem(res);
        });
    }
    checkCryptoKey(key, keyUsage) {
        super.checkCryptoKey(key, keyUsage);
        AesCrypto.checkCryptoKey(key);
    }
    internalEncrypt(algorithm, key, data, encrypt) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                const aesKey = CryptoKeyStorage.getItem(key).native;
                const func = encrypt
                    ? aesKey.encryptEcb.bind(aesKey)
                    : aesKey.decryptEcb.bind(aesKey);
                func(Buffer.from(data), (err, data2) => {
                    if (err) {
                        reject(err);
                    }
                    else {
                        resolve(core.BufferSourceConverter.toArrayBuffer(data2.buffer));
                    }
                });
            });
        });
    }
}

class DesCryptoKey extends SymmetricKey {
    toJSON() {
        return {
            kty: "oct",
            alg: this.algorithm.name === "DES-CBC"
                ? this.algorithm.name
                : "3DES-CBC",
            ext: true,
            k: Convert.ToBase64Url(this.native),
            key_ops: this.usages,
        };
    }
}

class DesCrypto {
    static generateKey(algorithm, extractable, keyUsages) {
        return __awaiter(this, void 0, void 0, function* () {
            const key = DesCryptoKey.create(Object.assign(Object.assign({}, algorithm), { name: algorithm.name.toUpperCase() }), "secret", extractable, keyUsages);
            key.native = crypto.randomBytes(algorithm.length >> 3);
            return key;
        });
    }
    static exportKey(format, key) {
        return __awaiter(this, void 0, void 0, function* () {
            const desKey = CryptoKeyStorage.getItem(key);
            switch (format.toLowerCase()) {
                case "jwk":
                    return desKey.toJSON();
                case "raw":
                    return new Uint8Array(desKey.native).buffer;
                default:
                    throw new core.OperationError("format: Must be 'jwk' or 'raw'");
            }
        });
    }
    static importKey(format, keyData, algorithm, extractable, keyUsages) {
        return __awaiter(this, void 0, void 0, function* () {
            let raw;
            switch (format.toLowerCase()) {
                case "jwk":
                    const jwk = keyData;
                    raw = Convert.FromBase64Url(jwk.k);
                    break;
                case "raw":
                    raw = keyData;
                    break;
                default:
                    throw new core.OperationError("format: Must be 'jwk' or 'raw'");
            }
            const desKey = DesCryptoKey.create(algorithm, "secret", extractable, keyUsages);
            desKey.algorithm.length = raw.byteLength >> 3;
            desKey.native = Buffer.from(raw);
            return desKey;
        });
    }
    static encrypt(algorithm, key, data) {
        return __awaiter(this, void 0, void 0, function* () {
            switch (algorithm.name.toUpperCase()) {
                case "DES-CBC":
                case "DES-EDE3-CBC":
                    return this.internalEncrypt(algorithm, key, Buffer.from(data), true);
                default:
                    throw new core.OperationError("algorithm: Is not recognized");
            }
        });
    }
    static decrypt(algorithm, key, data) {
        return __awaiter(this, void 0, void 0, function* () {
            switch (algorithm.name.toUpperCase()) {
                case "DES-CBC":
                case "DES-EDE3-CBC":
                    return this.internalEncrypt(algorithm, key, Buffer.from(data), false);
                default:
                    throw new core.OperationError("algorithm: Is not recognized");
            }
        });
    }
    static internalEncrypt(algorithm, key, data, encrypt) {
        return __awaiter(this, void 0, void 0, function* () {
            const func = encrypt
                ? crypto.createCipheriv
                : crypto.createDecipheriv;
            const decipher = func.call(crypto, algorithm.name.toLowerCase(), key.native, core.BufferSourceConverter.toUint8Array(algorithm.iv));
            let resMessage = decipher.update(data);
            resMessage = Buffer.concat([resMessage, decipher.final()]);
            return new Uint8Array(resMessage).buffer;
        });
    }
}

class DesCbcProvider extends core.DesProvider {
    constructor() {
        super(...arguments);
        this.keySizeBits = 64;
        this.ivSize = 8;
        this.name = "DES-CBC";
    }
    onGenerateKey(algorithm, extractable, keyUsages) {
        return __awaiter(this, void 0, void 0, function* () {
            const key = yield DesCrypto.generateKey({
                name: this.name,
                length: this.keySizeBits,
            }, extractable, keyUsages);
            return key;
        });
    }
    onEncrypt(algorithm, key, data) {
        return __awaiter(this, void 0, void 0, function* () {
            const desKey = CryptoKeyStorage.getItem(key);
            return DesCrypto.encrypt(algorithm, desKey, new Uint8Array(data));
        });
    }
    onDecrypt(algorithm, key, data) {
        return __awaiter(this, void 0, void 0, function* () {
            const desKey = CryptoKeyStorage.getItem(key);
            return DesCrypto.decrypt(algorithm, desKey, new Uint8Array(data));
        });
    }
    onExportKey(format, key) {
        return __awaiter(this, void 0, void 0, function* () {
            return DesCrypto.exportKey(format, key);
        });
    }
    onImportKey(format, keyData, algorithm, extractable, keyUsages) {
        return __awaiter(this, void 0, void 0, function* () {
            const key = yield DesCrypto.importKey(format, keyData, { name: this.name, length: this.keySizeBits }, extractable, keyUsages);
            if (key.native.length !== (this.keySizeBits >> 3)) {
                throw new core.OperationError("keyData: Wrong key size");
            }
            return CryptoKeyStorage.setItem(key);
        });
    }
    checkCryptoKey(key, keyUsage) {
        super.checkCryptoKey(key, keyUsage);
        if (!(CryptoKeyStorage.getItem(key) instanceof DesCryptoKey)) {
            throw new TypeError("key: Is not a DES CryptoKey");
        }
    }
}

class DesEde3CbcProvider extends core.DesProvider {
    constructor() {
        super(...arguments);
        this.keySizeBits = 192;
        this.ivSize = 8;
        this.name = "DES-EDE3-CBC";
    }
    onGenerateKey(algorithm, extractable, keyUsages) {
        return __awaiter(this, void 0, void 0, function* () {
            const key = yield DesCrypto.generateKey({
                name: this.name,
                length: this.keySizeBits,
            }, extractable, keyUsages);
            return key;
        });
    }
    onEncrypt(algorithm, key, data) {
        return __awaiter(this, void 0, void 0, function* () {
            const desKey = CryptoKeyStorage.getItem(key);
            return DesCrypto.encrypt(algorithm, desKey, new Uint8Array(data));
        });
    }
    onDecrypt(algorithm, key, data) {
        return __awaiter(this, void 0, void 0, function* () {
            const desKey = CryptoKeyStorage.getItem(key);
            return DesCrypto.decrypt(algorithm, desKey, new Uint8Array(data));
        });
    }
    onExportKey(format, key) {
        return __awaiter(this, void 0, void 0, function* () {
            return DesCrypto.exportKey(format, key);
        });
    }
    onImportKey(format, keyData, algorithm, extractable, keyUsages) {
        return __awaiter(this, void 0, void 0, function* () {
            const key = yield DesCrypto.importKey(format, keyData, { name: this.name, length: this.keySizeBits }, extractable, keyUsages);
            if (key.native.length !== (this.keySizeBits >> 3)) {
                throw new core.OperationError("keyData: Wrong key size");
            }
            return CryptoKeyStorage.setItem(key);
        });
    }
    checkCryptoKey(key, keyUsage) {
        super.checkCryptoKey(key, keyUsage);
        if (!(CryptoKeyStorage.getItem(key) instanceof DesCryptoKey)) {
            throw new TypeError("key: Is not a DES CryptoKey");
        }
    }
}

class EcPrivateKey extends AsymmetricKey {
    constructor() {
        super(...arguments);
        this.type = "private";
    }
}

class EcPublicKey extends AsymmetricKey {
    constructor() {
        super(...arguments);
        this.type = "public";
    }
}

const namedOIDs = {
    "1.2.840.10045.3.1.7": "P-256",
    "P-256": "1.2.840.10045.3.1.7",
    "1.3.132.0.34": "P-384",
    "P-384": "1.3.132.0.34",
    "1.3.132.0.35": "P-521",
    "P-521": "1.3.132.0.35",
    "1.3.132.0.10": "K-256",
    "K-256": "1.3.132.0.10",
};
function getOidByNamedCurve(namedCurve) {
    const oid = namedOIDs[namedCurve];
    if (!oid) {
        throw new core.OperationError(`Cannot convert WebCrypto named curve '${namedCurve}' to OID`);
    }
    return oid;
}

function buf_pad(buf, padSize = 0) {
    if (padSize && Buffer.length < padSize) {
        const pad = Buffer.from(new Uint8Array(padSize - buf.length).map((v) => 0));
        return Buffer.concat([pad, buf]);
    }
    return buf;
}
class EcCrypto {
    static generateKey(algorithm, extractable, keyUsages) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                const alg = algorithm;
                const namedCurve = this.getNamedCurve(alg.namedCurve);
                native.Key.generateEc(namedCurve, (err, key) => {
                    if (err) {
                        reject(err);
                    }
                    else {
                        const prvUsages = ["sign", "deriveKey", "deriveBits"]
                            .filter((usage) => keyUsages.some((keyUsage) => keyUsage === usage));
                        const pubUsages = ["verify"]
                            .filter((usage) => keyUsages.some((keyUsage) => keyUsage === usage));
                        const privateKey = EcPrivateKey.create(algorithm, "private", extractable, prvUsages);
                        const publicKey = EcPublicKey.create(algorithm, "public", true, pubUsages);
                        publicKey.native = privateKey.native = key;
                        resolve({
                            privateKey: CryptoKeyStorage.setItem(privateKey),
                            publicKey: CryptoKeyStorage.setItem(publicKey),
                        });
                    }
                });
            });
        });
    }
    static exportKey(format, key) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                const nativeKey = CryptoKeyStorage.getItem(key).native;
                const type = key.type === "public" ? native.KeyType.PUBLIC : native.KeyType.PRIVATE;
                switch (format.toLocaleLowerCase()) {
                    case "jwk":
                        nativeKey.exportJwk(type, (err, data) => {
                            if (err) {
                                throw new core.CryptoError(`Cannot export JWK key\n${err}`);
                            }
                            try {
                                const jwk = { kty: "EC", ext: true };
                                jwk.crv = key.algorithm.namedCurve;
                                jwk.key_ops = key.usages;
                                let padSize = 0;
                                switch (jwk.crv) {
                                    case "P-256":
                                    case "K-256":
                                        padSize = 32;
                                        break;
                                    case "P-384":
                                        padSize = 48;
                                        break;
                                    case "P-521":
                                        padSize = 66;
                                        break;
                                    default:
                                        throw new Error(`Unsupported named curve '${jwk.crv}'`);
                                }
                                jwk.x = Convert.ToBase64Url(buf_pad(data.x, padSize));
                                jwk.y = Convert.ToBase64Url(buf_pad(data.y, padSize));
                                if (key.type === "private") {
                                    jwk.d = Convert.ToBase64Url(buf_pad(data.d, padSize));
                                }
                                resolve(jwk);
                            }
                            catch (e) {
                                reject(e);
                            }
                        });
                        break;
                    case "spki":
                        nativeKey.exportSpki((err, raw) => {
                            if (err) {
                                reject(err);
                            }
                            else {
                                resolve(core.BufferSourceConverter.toArrayBuffer(raw));
                            }
                        });
                        break;
                    case "pkcs8":
                        nativeKey.exportPkcs8((err, raw) => {
                            if (err) {
                                reject(err);
                            }
                            else {
                                resolve(core.BufferSourceConverter.toArrayBuffer(raw));
                            }
                        });
                        break;
                    case "raw":
                        nativeKey.exportJwk(type, (err, data) => {
                            if (err) {
                                reject(err);
                            }
                            else {
                                let padSize = 0;
                                const crv = key.algorithm.namedCurve;
                                switch (crv) {
                                    case "P-256":
                                    case "K-256":
                                        padSize = 32;
                                        break;
                                    case "P-384":
                                        padSize = 48;
                                        break;
                                    case "P-521":
                                        padSize = 66;
                                        break;
                                    default:
                                        throw new Error(`Unsupported named curve '${crv}'`);
                                }
                                const x = buf_pad(data.x, padSize);
                                const y = buf_pad(data.y, padSize);
                                const rawKey = new Uint8Array(1 + x.length + y.length);
                                rawKey.set([4]);
                                rawKey.set(x, 1);
                                rawKey.set(y, 1 + x.length);
                                resolve(core.BufferSourceConverter.toArrayBuffer(rawKey));
                            }
                        });
                        break;
                    default:
                        throw new core.CryptoError(`ExportKey: Unknown export format '${format}'`);
                }
            });
        });
    }
    static importKey(format, keyData, algorithm, extractable, keyUsages) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                const formatLC = format.toLocaleLowerCase();
                const data = {};
                let keyType = native.KeyType.PUBLIC;
                switch (formatLC) {
                    case "raw": {
                        let keyLength = 0;
                        const rawData = Buffer.from(keyData);
                        if (rawData.byteLength === 65) {
                            keyLength = 32;
                        }
                        else if (rawData.byteLength === 97) {
                            keyLength = 48;
                        }
                        else if (rawData.byteLength === 133) {
                            keyLength = 66;
                        }
                        const x = Buffer.from(rawData).slice(1, keyLength + 1);
                        const y = Buffer.from(rawData).slice(keyLength + 1, (keyLength * 2) + 1);
                        data["kty"] = Buffer.from("EC", "utf-8");
                        data["crv"] = this.getNamedCurve(algorithm.namedCurve.toUpperCase());
                        data["x"] = buf_pad(x, keyLength);
                        data["y"] = buf_pad(y, keyLength);
                        native.Key.importJwk(data, keyType, (err, key) => {
                            try {
                                if (err) {
                                    reject(new core.CryptoError(`ImportKey: Cannot import key from JWK\n${err}`));
                                }
                                else {
                                    const ecKey = EcPublicKey.create(algorithm, "public", extractable, keyUsages);
                                    ecKey.native = key;
                                    resolve(CryptoKeyStorage.setItem(ecKey));
                                }
                            }
                            catch (e) {
                                reject(e);
                            }
                        });
                        break;
                    }
                    case "jwk": {
                        const jwk = keyData;
                        data["kty"] = jwk.kty;
                        data["crv"] = this.getNamedCurve(jwk.crv);
                        data["x"] = Buffer.from(Convert.FromBase64Url(jwk.x));
                        data["y"] = Buffer.from(Convert.FromBase64Url(jwk.y));
                        if (jwk.d) {
                            keyType = native.KeyType.PRIVATE;
                            data["d"] = Buffer.from(Convert.FromBase64Url(jwk.d));
                        }
                        native.Key.importJwk(data, keyType, (err, key) => {
                            try {
                                if (err) {
                                    reject(new core.CryptoError(`ImportKey: Cannot import key from JWK\n${err}`));
                                }
                                else {
                                    const Key = jwk.d ? EcPrivateKey : EcPublicKey;
                                    const ecKey = Key.create(algorithm, jwk.d ? "private" : "public", extractable, keyUsages);
                                    ecKey.native = key;
                                    resolve(CryptoKeyStorage.setItem(ecKey));
                                }
                            }
                            catch (e) {
                                reject(e);
                            }
                        });
                        break;
                    }
                    case "pkcs8":
                    case "spki": {
                        let importFunction = native.Key.importPkcs8;
                        if (formatLC === "spki") {
                            importFunction = native.Key.importSpki;
                        }
                        const rawData = Buffer.from(keyData);
                        importFunction(rawData, (err, key) => {
                            try {
                                if (err) {
                                    reject(new core.CryptoError(`ImportKey: Can not import key for ${format}\n${err.message}`));
                                }
                                else {
                                    let parameters;
                                    if (formatLC === "spki") {
                                        const keyInfo = AsnParser.parse(new Uint8Array(keyData), core.asn1.PublicKeyInfo);
                                        parameters = keyInfo.publicKeyAlgorithm.parameters;
                                    }
                                    else {
                                        const keyInfo = AsnParser.parse(new Uint8Array(keyData), core.asn1.PrivateKeyInfo);
                                        parameters = keyInfo.privateKeyAlgorithm.parameters;
                                    }
                                    if (!parameters) {
                                        throw new core.CryptoError("Key info doesn't have required parameters");
                                    }
                                    let namedCurveIdentifier = "";
                                    try {
                                        namedCurveIdentifier = AsnParser.parse(parameters, core.asn1.ObjectIdentifier).value;
                                    }
                                    catch (e) {
                                        throw new core.CryptoError("Cannot read key info parameters");
                                    }
                                    if (getOidByNamedCurve(algorithm.namedCurve) !== namedCurveIdentifier) {
                                        throw new core.CryptoError("Key info parameter doesn't match to named curve");
                                    }
                                    const Key = formatLC === "pkcs8" ? EcPrivateKey : EcPublicKey;
                                    const ecKey = Key.create(algorithm, formatLC === "pkcs8" ? "private" : "public", extractable, keyUsages);
                                    ecKey.native = key;
                                    resolve(CryptoKeyStorage.setItem(ecKey));
                                }
                            }
                            catch (e) {
                                reject(e);
                            }
                        });
                        break;
                    }
                    default:
                        throw new core.CryptoError(`ImportKey: Wrong format value '${format}'`);
                }
            });
        });
    }
    static checkCryptoKey(key) {
        if (!(key instanceof EcPrivateKey || key instanceof EcPublicKey)) {
            throw new TypeError("key: Is not EC CryptoKey");
        }
    }
    static getNamedCurve(namedCurve) {
        switch (namedCurve.toUpperCase()) {
            case "P-192":
                namedCurve = "secp192r1";
                break;
            case "P-256":
                namedCurve = "secp256r1";
                break;
            case "P-384":
                namedCurve = "secp384r1";
                break;
            case "P-521":
                namedCurve = "secp521r1";
                break;
            case "K-256":
                namedCurve = "secp256k1";
                break;
            default:
                throw new core.CryptoError("Unsupported namedCurve in use");
        }
        return native.EcNamedCurves[namedCurve];
    }
}
EcCrypto.publicKeyUsages = ["verify"];
EcCrypto.privateKeyUsages = ["sign", "deriveKey", "deriveBits"];

class EcdsaProvider extends core.EcdsaProvider {
    constructor() {
        super(...arguments);
        this.namedCurves = ["P-256", "P-384", "P-521", "K-256"];
    }
    onGenerateKey(algorithm, extractable, keyUsages) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield EcCrypto.generateKey(Object.assign(Object.assign({}, algorithm), { name: this.name }), extractable, keyUsages);
        });
    }
    onSign(algorithm, key, data) {
        return new Promise((resolve, reject) => {
            const alg = this.getOsslAlgorithm(algorithm);
            const nativeKey = CryptoKeyStorage.getItem(key).native;
            nativeKey.sign(alg, Buffer.from(data), (err, signature) => {
                if (err) {
                    reject(new core.CryptoError(`NativeError: ${err.message}`));
                }
                else {
                    resolve(core.BufferSourceConverter.toArrayBuffer(signature));
                }
            });
        });
    }
    onVerify(algorithm, key, signature, data) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                const alg = this.getOsslAlgorithm(algorithm);
                const nativeKey = CryptoKeyStorage.getItem(key).native;
                nativeKey.verify(alg, Buffer.from(data), Buffer.from(signature), (err, res) => {
                    if (err) {
                        reject(new core.CryptoError(`NativeError: ${err.message}`));
                    }
                    else {
                        resolve(res);
                    }
                });
            });
        });
    }
    onExportKey(format, key) {
        return __awaiter(this, void 0, void 0, function* () {
            return EcCrypto.exportKey(format, key);
        });
    }
    onImportKey(format, keyData, algorithm, extractable, keyUsages) {
        return __awaiter(this, void 0, void 0, function* () {
            return EcCrypto.importKey(format, keyData, Object.assign(Object.assign({}, algorithm), { name: this.name }), extractable, keyUsages);
        });
    }
    checkCryptoKey(key, keyUsage) {
        super.checkCryptoKey(key, keyUsage);
        EcCrypto.checkCryptoKey(CryptoKeyStorage.getItem(key));
    }
    getOsslAlgorithm(algorithm) {
        const alg = algorithm.hash.name.toUpperCase().replace("-", "");
        return alg;
    }
}

class EcdhProvider extends core.EcdhProvider {
    constructor() {
        super(...arguments);
        this.namedCurves = ["P-256", "P-384", "P-521", "K-256"];
    }
    onGenerateKey(algorithm, extractable, keyUsages) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield EcCrypto.generateKey(Object.assign(Object.assign({}, algorithm), { name: this.name }), extractable, keyUsages);
        });
    }
    onExportKey(format, key) {
        return __awaiter(this, void 0, void 0, function* () {
            return EcCrypto.exportKey(format, key);
        });
    }
    onImportKey(format, keyData, algorithm, extractable, keyUsages) {
        return __awaiter(this, void 0, void 0, function* () {
            return EcCrypto.importKey(format, keyData, Object.assign(Object.assign({}, algorithm), { name: this.name }), extractable, keyUsages);
        });
    }
    onDeriveBits(algorithm, baseKey, length) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                const nativeKey = CryptoKeyStorage.getItem(baseKey).native;
                const publicKey = CryptoKeyStorage.getItem(algorithm.public).native;
                nativeKey.EcdhDeriveBits(publicKey, length, (err, raw) => {
                    if (err) {
                        reject(err);
                    }
                    else {
                        resolve(core.BufferSourceConverter.toArrayBuffer(raw));
                    }
                });
            });
        });
    }
    checkCryptoKey(key, keyUsage) {
        super.checkCryptoKey(key, keyUsage);
        EcCrypto.checkCryptoKey(CryptoKeyStorage.getItem(key));
    }
}

class HmacCryptoKey extends CryptoKey {
}

class HmacProvider extends core.HmacProvider {
    onGenerateKey(algorithm, extractable, keyUsages) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                const length = (algorithm.length || this.getDefaultLength(algorithm.hash.name)) >> 3 << 3;
                native.HmacKey.generate(length, (err, key) => {
                    if (err) {
                        reject(err);
                    }
                    else {
                        const hmacKey = HmacCryptoKey.create(Object.assign(Object.assign({}, algorithm), { length }), "secret", extractable, keyUsages);
                        hmacKey.native = key;
                        resolve(CryptoKeyStorage.setItem(hmacKey));
                    }
                });
            });
        });
    }
    onSign(algorithm, key, data) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                const hmacKey = CryptoKeyStorage.getItem(key);
                const alg = this.getOsslAlgorithm(hmacKey.algorithm);
                const nativeKey = hmacKey.native;
                nativeKey.sign(alg, Buffer.from(data), (err, signature) => {
                    if (err) {
                        reject(new core.CryptoError(`NativeError: ${err.message}`));
                    }
                    else {
                        resolve(core.BufferSourceConverter.toArrayBuffer(signature));
                    }
                });
            });
        });
    }
    onVerify(algorithm, key, signature, data) {
        return __awaiter(this, void 0, void 0, function* () {
            const signature2 = yield this.sign(algorithm, key, data);
            return Buffer.from(signature2).compare(Buffer.from(signature)) === 0;
        });
    }
    onImportKey(format, keyData, algorithm, extractable, keyUsages) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                const formatLC = format.toLocaleLowerCase();
                let raw;
                switch (formatLC) {
                    case "jwk":
                        const jwk = keyData;
                        raw = Convert.FromBase64Url(jwk.k);
                        break;
                    case "raw":
                        raw = keyData;
                        break;
                    default:
                        throw new core.CryptoError(`ImportKey: Wrong format value '${format}'`);
                }
                native.HmacKey.import(Buffer.from(raw), (err, key) => {
                    if (err) {
                        reject(err);
                    }
                    else {
                        const hmacKey = HmacCryptoKey.create(algorithm, "secret", extractable, keyUsages);
                        hmacKey.native = key;
                        resolve(CryptoKeyStorage.setItem(hmacKey));
                    }
                });
            });
        });
    }
    onExportKey(format, key) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                const nativeKey = CryptoKeyStorage.getItem(key).native;
                switch (format.toLocaleLowerCase()) {
                    case "jwk":
                        const jwk = {
                            kty: "oct",
                            alg: "",
                            key_ops: key.usages,
                            k: "",
                            ext: true,
                        };
                        jwk.alg = "HS" + /-(\d+)$/.exec(key.algorithm.hash.name)[1];
                        nativeKey.export((err, data) => {
                            if (err) {
                                reject(err);
                            }
                            else {
                                jwk.k = Convert.ToBase64Url(data);
                                resolve(jwk);
                            }
                        });
                        break;
                    case "raw":
                        nativeKey.export((err, data) => {
                            if (err) {
                                reject(err);
                            }
                            else {
                                resolve(core.BufferSourceConverter.toArrayBuffer(data));
                            }
                        });
                        break;
                    default: throw new core.CryptoError(`ExportKey: Unknown export format '${format}'`);
                }
            });
        });
    }
    checkCryptoKey(key, keyUsage) {
        super.checkCryptoKey(key, keyUsage);
        if (!(CryptoKeyStorage.getItem(key) instanceof HmacCryptoKey)) {
            throw new TypeError("key: Is not HMAC CryptoKey");
        }
    }
    getOsslAlgorithm(algorithm) {
        const alg = algorithm.hash.name.toUpperCase().replace("-", "");
        return alg;
    }
}

class PbkdfCryptoKey extends CryptoKey {
}

class Pbkdf2Provider extends core.Pbkdf2Provider {
    getOsslAlgorithm(algorithm) {
        const alg = algorithm.name.toUpperCase().replace("-", "");
        return alg;
    }
    onDeriveBits(algorithm, baseKey, length) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                const nativeKey = CryptoKeyStorage.getItem(baseKey).native;
                const hash = algorithm.hash;
                const salt = Buffer.from(core.BufferSourceConverter.toArrayBuffer(algorithm.salt));
                nativeKey.deriveBits(this.getOsslAlgorithm(hash), salt, algorithm.iterations, length, (err, raw) => {
                    if (err) {
                        reject(err);
                    }
                    else {
                        resolve(core.BufferSourceConverter.toArrayBuffer(raw));
                    }
                });
            });
        });
    }
    onImportKey(format, keyData, algorithm, extractable, keyUsages) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                let raw;
                switch (format) {
                    case "raw":
                        raw = keyData;
                        break;
                    default:
                        throw new core.OperationError("format: Must be 'raw'");
                }
                native.Pbkdf2Key.importKey(Buffer.from(raw), (err, key) => {
                    if (err) {
                        reject(err);
                    }
                    else {
                        const pbkdf2Key = PbkdfCryptoKey.create(algorithm, "secret", false, keyUsages);
                        pbkdf2Key.native = key;
                        resolve(CryptoKeyStorage.setItem(pbkdf2Key));
                    }
                });
            });
        });
    }
    checkCryptoKey(key, keyUsage) {
        super.checkCryptoKey(key, keyUsage);
        if (!(CryptoKeyStorage.getItem(key) instanceof PbkdfCryptoKey)) {
            throw new TypeError("key: Is not PBKDF CryptoKey");
        }
    }
}

class RsaPrivateKey extends AsymmetricKey {
    constructor() {
        super(...arguments);
        this.type = "private";
    }
}

class RsaPublicKey extends AsymmetricKey {
    constructor() {
        super(...arguments);
        this.type = "public";
    }
}

class RsaCrypto {
    static generateKey(algorithm, extractable, keyUsages) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                const size = algorithm.modulusLength;
                const exp = Buffer.from(algorithm.publicExponent);
                let nExp = 0;
                if (exp.length === 3) {
                    nExp = 1;
                }
                native.Key.generateRsa(size, nExp, (err, key) => {
                    try {
                        if (err) {
                            reject(new core.CryptoError(`Rsa: Can not generate new key\n${err.message}`));
                        }
                        else {
                            const prvUsages = ["sign", "decrypt", "unwrapKey"]
                                .filter((usage) => keyUsages.some((keyUsage) => keyUsage === usage));
                            const pubUsages = ["verify", "encrypt", "wrapKey"]
                                .filter((usage) => keyUsages.some((keyUsage) => keyUsage === usage));
                            const privateKey = RsaPrivateKey.create(algorithm, "private", extractable, prvUsages);
                            const publicKey = RsaPublicKey.create(algorithm, "public", true, pubUsages);
                            privateKey.native = publicKey.native = key;
                            resolve({
                                privateKey: CryptoKeyStorage.setItem(privateKey),
                                publicKey: CryptoKeyStorage.setItem(publicKey),
                            });
                        }
                    }
                    catch (e) {
                        reject(e);
                    }
                });
            });
        });
    }
    static exportKey(format, key) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                const nativeKey = CryptoKeyStorage.getItem(key).native;
                const type = key.type === "public" ? native.KeyType.PUBLIC : native.KeyType.PRIVATE;
                switch (format.toLocaleLowerCase()) {
                    case "jwk":
                        nativeKey.exportJwk(type, (err, data) => {
                            if (err) {
                                throw new core.CryptoError(`Cannot export JWK key\n${err}`);
                            }
                            try {
                                const jwk = {
                                    kty: "RSA",
                                    ext: true,
                                    alg: this.getJwkAlgorithm(key.algorithm),
                                };
                                jwk.key_ops = key.usages;
                                jwk.e = Convert.ToBase64Url(data.e);
                                jwk.n = Convert.ToBase64Url(data.n);
                                if (key.type === "private") {
                                    jwk.d = Convert.ToBase64Url(data.d);
                                    jwk.p = Convert.ToBase64Url(data.p);
                                    jwk.q = Convert.ToBase64Url(data.q);
                                    jwk.dp = Convert.ToBase64Url(data.dp);
                                    jwk.dq = Convert.ToBase64Url(data.dq);
                                    jwk.qi = Convert.ToBase64Url(data.qi);
                                }
                                resolve(jwk);
                            }
                            catch (e) {
                                reject(e);
                            }
                        });
                        break;
                    case "spki":
                        nativeKey.exportSpki((err, raw) => {
                            if (err) {
                                reject(err);
                            }
                            else {
                                resolve(core.BufferSourceConverter.toArrayBuffer(raw));
                            }
                        });
                        break;
                    case "pkcs8":
                        nativeKey.exportPkcs8((err, raw) => {
                            if (err) {
                                reject(err);
                            }
                            else {
                                resolve(core.BufferSourceConverter.toArrayBuffer(raw));
                            }
                        });
                        break;
                    default:
                        throw new core.CryptoError(`ExportKey: Unknown export format '${format}'`);
                }
            });
        });
    }
    static importKey(format, keyData, algorithm, extractable, keyUsages) {
        return __awaiter(this, void 0, void 0, function* () {
            let keyType = native.KeyType.PUBLIC;
            return new Promise((resolve, reject) => {
                const formatLC = format.toLocaleLowerCase();
                switch (formatLC) {
                    case "jwk":
                        const jwk = keyData;
                        const data = {};
                        data["kty"] = jwk.kty;
                        data["n"] = Buffer.from(Convert.FromBase64Url(jwk.n));
                        data["e"] = Buffer.from(Convert.FromBase64Url(jwk.e));
                        if (jwk.d) {
                            keyType = native.KeyType.PRIVATE;
                            data["d"] = Buffer.from(Convert.FromBase64Url(jwk.d));
                            data["p"] = Buffer.from(Convert.FromBase64Url(jwk.p));
                            data["q"] = Buffer.from(Convert.FromBase64Url(jwk.q));
                            data["dp"] = Buffer.from(Convert.FromBase64Url(jwk.dp));
                            data["dq"] = Buffer.from(Convert.FromBase64Url(jwk.dq));
                            data["qi"] = Buffer.from(Convert.FromBase64Url(jwk.qi));
                        }
                        native.Key.importJwk(data, keyType, (err, key) => {
                            try {
                                if (err) {
                                    reject(new core.CryptoError(`ImportKey: Cannot import key from JWK\n${err}`));
                                }
                                else {
                                    resolve(key);
                                }
                            }
                            catch (e) {
                                reject(e);
                            }
                        });
                        break;
                    case "pkcs8":
                    case "spki":
                        let importFunction = native.Key.importSpki;
                        if (formatLC === "pkcs8") {
                            keyType = native.KeyType.PRIVATE;
                            importFunction = native.Key.importPkcs8;
                        }
                        importFunction(Buffer.from(keyData), (err, key) => {
                            try {
                                if (err) {
                                    reject(new core.CryptoError(`ImportKey: Can not import key for ${format}\n${err.message}`));
                                }
                                else {
                                    resolve(key);
                                }
                            }
                            catch (e) {
                                reject(e);
                            }
                        });
                        break;
                    default:
                        throw new core.CryptoError(`ImportKey: Wrong format value '${format}'`);
                }
            })
                .then((key) => {
                const alg = Object.assign(Object.assign({}, algorithm), { modulusLength: key.modulusLength() << 3, publicExponent: new Uint8Array(key.publicExponent()), hash: algorithm.hash });
                const Key = keyType
                    ? RsaPrivateKey
                    : RsaPublicKey;
                const rsaKey = Key.create(alg, keyType ? "private" : "public", extractable, keyUsages);
                rsaKey.native = key;
                return CryptoKeyStorage.setItem(rsaKey);
            });
        });
    }
    static checkCryptoKey(key) {
        if (!(key instanceof RsaPrivateKey || key instanceof RsaPublicKey)) {
            throw new TypeError("key: Is not RSA CryptoKey");
        }
    }
    static getJwkAlgorithm(algorithm) {
        switch (algorithm.name.toUpperCase()) {
            case "RSA-OAEP": {
                const mdSize = /(\d+)$/.exec(algorithm.hash.name)[1];
                return `RSA-OAEP${mdSize !== "1" ? `-${mdSize}` : ""}`;
            }
            case "RSASSA-PKCS1-V1_5":
                return `RS${/(\d+)$/.exec(algorithm.hash.name)[1]}`;
            case "RSA-PSS":
                return `PS${/(\d+)$/.exec(algorithm.hash.name)[1]}`;
            default:
                throw new core.OperationError("algorithm: Is not recognized");
        }
    }
}
RsaCrypto.publicKeyUsages = ["verify", "encrypt", "wrapKey"];
RsaCrypto.privateKeyUsages = ["sign", "decrypt", "unwrapKey"];

class RsaSsaProvider extends core.RsaSsaProvider {
    onGenerateKey(algorithm, extractable, keyUsages) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield RsaCrypto.generateKey(Object.assign(Object.assign({}, algorithm), { name: this.name }), extractable, keyUsages);
        });
    }
    onSign(algorithm, key, data) {
        return new Promise((resolve, reject) => {
            const rsaKey = CryptoKeyStorage.getItem(key);
            const alg = this.getOsslAlgorithm(rsaKey.algorithm);
            const nativeKey = rsaKey.native;
            nativeKey.sign(alg, Buffer.from(data), (err, signature) => {
                if (err) {
                    reject(new core.CryptoError(`NativeError: ${err.message}`));
                }
                else {
                    resolve(signature.buffer);
                }
            });
        });
    }
    onVerify(algorithm, key, signature, data) {
        return new Promise((resolve, reject) => {
            const rsaKey = CryptoKeyStorage.getItem(key);
            const alg = this.getOsslAlgorithm(rsaKey.algorithm);
            const nativeKey = rsaKey.native;
            nativeKey.verify(alg, Buffer.from(data), Buffer.from(signature), (err, res) => {
                if (err) {
                    reject(new core.CryptoError(`NativeError: ${err.message}`));
                }
                else {
                    resolve(res);
                }
            });
        });
    }
    onExportKey(format, key) {
        return __awaiter(this, void 0, void 0, function* () {
            return RsaCrypto.exportKey(format, key);
        });
    }
    onImportKey(format, keyData, algorithm, extractable, keyUsages) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield RsaCrypto.importKey(format, keyData, Object.assign(Object.assign({}, algorithm), { name: this.name }), extractable, keyUsages);
        });
    }
    checkCryptoKey(key, keyUsage) {
        super.checkCryptoKey(key, keyUsage);
        RsaCrypto.checkCryptoKey(CryptoKeyStorage.getItem(key));
    }
    getOsslAlgorithm(algorithm) {
        const alg = algorithm.hash.name.toUpperCase().replace("-", "");
        return alg;
    }
}

class RsaPssProvider extends core.RsaPssProvider {
    onGenerateKey(algorithm, extractable, keyUsages) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield RsaCrypto.generateKey(Object.assign(Object.assign({}, algorithm), { name: this.name }), extractable, keyUsages);
        });
    }
    onSign(algorithm, key, data) {
        return new Promise((resolve, reject) => {
            const rsaKey = CryptoKeyStorage.getItem(key);
            const alg = this.getOsslAlgorithm(rsaKey.algorithm);
            const nativeKey = rsaKey.native;
            nativeKey.RsaPssSign(alg, algorithm.saltLength, Buffer.from(data), (err, signature) => {
                if (err) {
                    reject(new core.CryptoError("NativeError: " + err.message));
                }
                else {
                    resolve(core.BufferSourceConverter.toArrayBuffer(signature));
                }
            });
        });
    }
    onVerify(algorithm, key, signature, data) {
        return new Promise((resolve, reject) => {
            const rsaKey = CryptoKeyStorage.getItem(key);
            const alg = this.getOsslAlgorithm(rsaKey.algorithm);
            const nativeKey = rsaKey.native;
            nativeKey.RsaPssVerify(alg, algorithm.saltLength, Buffer.from(data), Buffer.from(signature), (err, res) => {
                if (err) {
                    reject(new core.CryptoError("NativeError: " + err.message));
                }
                else {
                    resolve(res);
                }
            });
        });
    }
    onExportKey(format, key) {
        return __awaiter(this, void 0, void 0, function* () {
            return RsaCrypto.exportKey(format, key);
        });
    }
    onImportKey(format, keyData, algorithm, extractable, keyUsages) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield RsaCrypto.importKey(format, keyData, Object.assign(Object.assign({}, algorithm), { name: this.name }), extractable, keyUsages);
        });
    }
    checkCryptoKey(key, keyUsage) {
        super.checkCryptoKey(key, keyUsage);
        RsaCrypto.checkCryptoKey(CryptoKeyStorage.getItem(key));
    }
    getOsslAlgorithm(algorithm) {
        const alg = algorithm.hash.name.toUpperCase().replace("-", "");
        return alg;
    }
}

class RsaOaepProvider extends core.RsaOaepProvider {
    onGenerateKey(algorithm, extractable, keyUsages) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield RsaCrypto.generateKey(Object.assign(Object.assign({}, algorithm), { name: this.name }), extractable, keyUsages);
        });
    }
    onEncrypt(algorithm, key, data) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.internalEncrypt(algorithm, key, Buffer.from(data), true);
        });
    }
    onDecrypt(algorithm, key, data) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.internalEncrypt(algorithm, key, Buffer.from(data), false);
        });
    }
    onExportKey(format, key) {
        return __awaiter(this, void 0, void 0, function* () {
            return RsaCrypto.exportKey(format, key);
        });
    }
    onImportKey(format, keyData, algorithm, extractable, keyUsages) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield RsaCrypto.importKey(format, keyData, Object.assign(Object.assign({}, algorithm), { name: this.name }), extractable, keyUsages);
        });
    }
    checkCryptoKey(key, keyUsage) {
        super.checkCryptoKey(key, keyUsage);
        RsaCrypto.checkCryptoKey(CryptoKeyStorage.getItem(key));
    }
    getOsslAlgorithm(algorithm) {
        const alg = algorithm.hash.name.toUpperCase().replace("-", "");
        return alg;
    }
    internalEncrypt(algorithm, key, data, encrypt) {
        return new Promise((resolve, reject) => {
            const rsaKey = CryptoKeyStorage.getItem(key);
            const nativeKey = rsaKey.native;
            const alg = this.getOsslAlgorithm(rsaKey.algorithm);
            let label = null;
            if (algorithm.label) {
                label = Buffer.from(core.BufferSourceConverter.toArrayBuffer(algorithm.label));
            }
            nativeKey.RsaOaepEncDec(alg, data, label, !encrypt, (err, res) => {
                if (err) {
                    reject(new core.CryptoError("NativeError: " + err));
                }
                else {
                    resolve(core.BufferSourceConverter.toArrayBuffer(res));
                }
            });
        });
    }
}

class ShaCrypto {
    static size(algorithm) {
        switch (algorithm.name.toUpperCase()) {
            case "SHA-1":
                return 160;
            case "SHA-256":
                return 256;
            case "SHA-384":
                return 384;
            case "SHA-512":
                return 512;
            default:
                throw new Error("Unrecognized name");
        }
    }
    static digest(algorithm, data) {
        return new Promise((resolve, reject) => {
            const algName = algorithm.name.toLowerCase();
            switch (algName) {
                case "sha-1":
                case "sha-256":
                case "sha-384":
                case "sha-512":
                    native.Core.digest(algName.replace("-", ""), Buffer.from(data), (err, digest) => {
                        if (err) {
                            reject(err);
                        }
                        else {
                            resolve(digest.buffer);
                        }
                    });
                    break;
                default:
                    throw new core.AlgorithmError("Unsupported algorithm");
            }
        });
    }
}

class Sha1Provider extends core.ProviderCrypto {
    constructor() {
        super(...arguments);
        this.name = "SHA-1";
        this.usages = [];
    }
    onDigest(algorithm, data) {
        return __awaiter(this, void 0, void 0, function* () {
            return ShaCrypto.digest(algorithm, data);
        });
    }
}

class Sha256Provider extends core.ProviderCrypto {
    constructor() {
        super(...arguments);
        this.name = "SHA-256";
        this.usages = [];
    }
    onDigest(algorithm, data) {
        return __awaiter(this, void 0, void 0, function* () {
            return ShaCrypto.digest(algorithm, data);
        });
    }
}

class Sha384Provider extends core.ProviderCrypto {
    constructor() {
        super(...arguments);
        this.name = "SHA-384";
        this.usages = [];
    }
    onDigest(algorithm, data) {
        return __awaiter(this, void 0, void 0, function* () {
            return ShaCrypto.digest(algorithm, data);
        });
    }
}

class Sha512Provider extends core.ProviderCrypto {
    constructor() {
        super(...arguments);
        this.name = "SHA-512";
        this.usages = [];
    }
    onDigest(algorithm, data) {
        return __awaiter(this, void 0, void 0, function* () {
            return ShaCrypto.digest(algorithm, data);
        });
    }
}

class SubtleCrypto extends core.SubtleCrypto {
    constructor() {
        super();
        this.providers.set(new AesCbcProvider());
        this.providers.set(new AesCtrProvider());
        this.providers.set(new AesGcmProvider());
        this.providers.set(new AesCmacProvider());
        this.providers.set(new AesKwProvider());
        this.providers.set(new AesEcbProvider());
        this.providers.set(new DesCbcProvider());
        this.providers.set(new DesEde3CbcProvider());
        this.providers.set(new RsaSsaProvider());
        this.providers.set(new RsaPssProvider());
        this.providers.set(new RsaOaepProvider());
        this.providers.set(new EcdsaProvider());
        this.providers.set(new EcdhProvider());
        this.providers.set(new Sha1Provider());
        this.providers.set(new Sha256Provider());
        this.providers.set(new Sha384Provider());
        this.providers.set(new Sha512Provider());
        this.providers.set(new Pbkdf2Provider());
        this.providers.set(new HmacProvider());
    }
}

class Crypto extends core.Crypto {
    constructor(options) {
        super();
        this.subtle = new SubtleCrypto();
        if (options === null || options === void 0 ? void 0 : options.directory) {
            this.keyStorage = new CryptoKeyStorage$1(this, options.directory);
        }
    }
    getRandomValues(array) {
        if (ArrayBuffer.isView(array)) {
            if (array.byteLength > 65536) {
                throw new core.OperationError(`Failed to execute 'getRandomValues' on 'Crypto': The ArrayBufferView's byte length (${array.byteLength}) exceeds the number of bytes of entropy available via this API (65536).`);
            }
            const bytes = crypto.randomBytes(array.byteLength);
            array.set(new array.constructor(bytes.buffer));
            return array;
        }
        else {
            throw new core.OperationError(`Failed to execute 'getRandomValues' on 'Crypto': Expected ArrayBufferView for 'array' argument.`);
        }
    }
}

export { Crypto };
