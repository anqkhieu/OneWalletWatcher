"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Stream = exports.StreamOperation = exports.GroupKey = void 0;
const node_fetch_1 = __importDefault(require("node-fetch"));
const address_1 = require("@ethersproject/address");
const utils_1 = require("../utils");
const authFetch_1 = __importDefault(require("../rest/authFetch"));
var Encryption_1 = require("./encryption/Encryption");
Object.defineProperty(exports, "GroupKey", { enumerable: true, get: function () { return Encryption_1.GroupKey; } });
const StorageNode_1 = require("./StorageNode");
var StreamOperation;
(function (StreamOperation) {
    StreamOperation["STREAM_GET"] = "stream_get";
    StreamOperation["STREAM_EDIT"] = "stream_edit";
    StreamOperation["STREAM_DELETE"] = "stream_delete";
    StreamOperation["STREAM_PUBLISH"] = "stream_publish";
    StreamOperation["STREAM_SUBSCRIBE"] = "stream_subscribe";
    StreamOperation["STREAM_SHARE"] = "stream_share";
})(StreamOperation = exports.StreamOperation || (exports.StreamOperation = {}));
const VALID_FIELD_TYPES = ['number', 'string', 'boolean', 'list', 'map'];
function getFieldType(value) {
    const type = typeof value;
    switch (true) {
        case Array.isArray(value): {
            return 'list';
        }
        case type === 'object': {
            return 'map';
        }
        case VALID_FIELD_TYPES.includes(type): {
            // see https://github.com/microsoft/TypeScript/issues/36275
            return type;
        }
        default: {
            return undefined;
        }
    }
}
class StreamrStream {
    constructor(client, props) {
        this.config = { fields: [] };
        this._client = client;
        Object.assign(this, props);
    }
    async update() {
        const json = await authFetch_1.default(utils_1.getEndpointUrl(this._client.options.restUrl, 'streams', this.id), this._client.session, {
            method: 'PUT',
            body: JSON.stringify(this.toObject()),
        });
        return json ? new StreamrStream(this._client, json) : undefined;
    }
    /** @internal */
    toObject() {
        const result = {};
        Object.keys(this).forEach((key) => {
            if (!key.startsWith('_')) {
                // @ts-expect-error
                result[key] = this[key];
            }
        });
        return result;
    }
    async delete() {
        await authFetch_1.default(utils_1.getEndpointUrl(this._client.options.restUrl, 'streams', this.id), this._client.session, {
            method: 'DELETE',
        });
    }
    async getPermissions() {
        return authFetch_1.default(utils_1.getEndpointUrl(this._client.options.restUrl, 'streams', this.id, 'permissions'), this._client.session);
    }
    async getMyPermissions() {
        return authFetch_1.default(utils_1.getEndpointUrl(this._client.options.restUrl, 'streams', this.id, 'permissions', 'me'), this._client.session);
    }
    async hasPermission(operation, userId) {
        // eth addresses may be in checksumcase, but userId from server has no case
        const userIdCaseInsensitive = typeof userId === 'string' ? userId.toLowerCase() : undefined; // if not string then undefined
        const permissions = await this.getPermissions();
        return permissions.find((p) => {
            if (p.operation !== operation) {
                return false;
            }
            if (userIdCaseInsensitive === undefined) {
                return !!p.anonymous; // match nullish userId against p.anonymous
            }
            return p.user && p.user.toLowerCase() === userIdCaseInsensitive; // match against userId
        });
    }
    async grantPermission(operation, userId) {
        const permissionObject = {
            operation,
        };
        const userIdCaseInsensitive = typeof userId === 'string' ? userId.toLowerCase() : undefined;
        if (userIdCaseInsensitive !== undefined) {
            permissionObject.user = userIdCaseInsensitive;
        }
        else {
            permissionObject.anonymous = true;
        }
        return authFetch_1.default(utils_1.getEndpointUrl(this._client.options.restUrl, 'streams', this.id, 'permissions'), this._client.session, {
            method: 'POST',
            body: JSON.stringify(permissionObject),
        });
    }
    async revokePermission(permissionId) {
        await authFetch_1.default(utils_1.getEndpointUrl(this._client.options.restUrl, 'streams', this.id, 'permissions', String(permissionId)), this._client.session, {
            method: 'DELETE',
        });
    }
    async detectFields() {
        // Get last message of the stream to be used for field detecting
        const sub = await this._client.resend({
            stream: this.id,
            resend: {
                last: 1,
            },
        });
        const receivedMsgs = await sub.collect();
        if (!receivedMsgs.length) {
            return;
        }
        const [lastMessage] = receivedMsgs;
        const fields = Object.entries(lastMessage).map(([name, value]) => {
            const type = getFieldType(value);
            return !!type && {
                name,
                type,
            };
        }).filter(Boolean); // see https://github.com/microsoft/TypeScript/issues/30621
        // Save field config back to the stream
        this.config.fields = fields;
        await this.update();
    }
    async addToStorageNode(node, { timeout = 30000, pollInterval = 200 } = {}) {
        const address = (node instanceof StorageNode_1.StorageNode) ? node.getAddress() : node;
        // currently we support only one storage node
        // -> we can validate that the given address is that address
        // -> remove this comparison when we start to support multiple storage nodes
        if (address_1.getAddress(address) !== this._client.options.storageNode.address) {
            throw new Error('Unknown storage node: ' + address);
        }
        await authFetch_1.default(utils_1.getEndpointUrl(this._client.options.restUrl, 'streams', this.id, 'storageNodes'), this._client.session, {
            method: 'POST',
            body: JSON.stringify({
                address
            })
        });
        // wait for propagation: the storage node sees the database change in E&E and
        // is ready to store the any stream data which we publish
        await utils_1.until(() => this.isStreamStoredInStorageNode(this.id), timeout, pollInterval, () => (`Propagation timeout when adding stream to a storage node: ${this.id}`));
    }
    async isStreamStoredInStorageNode(streamId) {
        const url = `${this._client.options.storageNode.url}/api/v1/streams/${encodeURIComponent(streamId)}/storage/partitions/0`;
        const response = await node_fetch_1.default(url);
        if (response.status === 200) {
            return true;
        }
        if (response.status === 404) { // eslint-disable-line padding-line-between-statements
            return false;
        }
        throw new Error(`Unexpected response code ${response.status} when fetching stream storage status`);
    }
    async removeFromStorageNode(node) {
        const address = (node instanceof StorageNode_1.StorageNode) ? node.getAddress() : node;
        await authFetch_1.default(utils_1.getEndpointUrl(this._client.options.restUrl, 'streams', this.id, 'storageNodes', address), this._client.session, {
            method: 'DELETE'
        });
    }
    async getStorageNodes() {
        const json = await authFetch_1.default(utils_1.getEndpointUrl(this._client.options.restUrl, 'streams', this.id, 'storageNodes'), this._client.session);
        return json.map((item) => new StorageNode_1.StorageNode(item.storageNodeAddress));
    }
    async publish(content, timestamp, partitionKey) {
        return this._client.publish(this.id, content, timestamp, partitionKey);
    }
}
exports.Stream = StreamrStream;
//# sourceMappingURL=index.js.map