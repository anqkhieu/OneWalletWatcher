"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.resend = exports.unsubscribe = exports.subscribe = void 0;
const util_1 = require("util");
const streamr_client_protocol_1 = require("streamr-client-protocol");
const utils_1 = require("../utils");
const utils_2 = require("../stream/utils");
const { SubscribeRequest, UnsubscribeRequest, ResendLastRequest, ResendFromRequest, ResendRangeRequest, } = streamr_client_protocol_1.ControlLayer;
const { MessageRef } = streamr_client_protocol_1.MessageLayer;
/**
 * Subscribe Request
 */
async function subscribe(client, { streamId, streamPartition = 0 }) {
    const sessionToken = await client.session.getSessionToken();
    const request = new SubscribeRequest({
        streamId,
        streamPartition,
        sessionToken,
        requestId: utils_1.uuid('sub'),
    });
    const onResponse = utils_2.waitForRequestResponse(client, request);
    await client.send(request);
    return onResponse;
}
exports.subscribe = subscribe;
/**
 * Unsubscribe Request
 */
async function unsubscribe(client, { streamId, streamPartition = 0 }) {
    const { connection } = client;
    // disconnection auto-unsubs
    // if already disconnected/disconnecting no need to send unsub
    const needsUnsubscribe = (connection.isConnectionValid()
        && !connection.isDisconnected()
        && !connection.isDisconnecting());
    if (!needsUnsubscribe) {
        return Promise.resolve();
    }
    const sessionToken = await client.session.getSessionToken();
    const request = new UnsubscribeRequest({
        streamId,
        streamPartition,
        sessionToken,
        requestId: utils_1.uuid('unsub'),
    });
    const onResponse = utils_2.waitForRequestResponse(client, request).catch((err) => {
        // noop if unsubscribe failed because we are already unsubscribed
        if (err.message.contains('Not subscribed to stream')) {
            return;
        }
        throw err;
    });
    await client.send(request);
    return onResponse;
}
exports.unsubscribe = unsubscribe;
/**
 * Resend Request
 */
function createResendRequest(resendOptions) {
    const { requestId = utils_1.uuid('rs'), streamId, streamPartition = 0, sessionToken, ...options } = resendOptions;
    const { from, to, last, publisherId, msgChainId } = {
        ...options,
        ...options.resend
    };
    const commonOpts = {
        streamId,
        streamPartition,
        requestId,
        sessionToken,
    };
    let request;
    if (last > 0) {
        request = new ResendLastRequest({
            ...commonOpts,
            numberLast: last,
        });
    }
    else if (from && !to) {
        request = new ResendFromRequest({
            ...commonOpts,
            fromMsgRef: new MessageRef(from.timestamp, from.sequenceNumber),
            publisherId
        });
    }
    else if (from && to) {
        request = new ResendRangeRequest({
            ...commonOpts,
            fromMsgRef: new MessageRef(from.timestamp, from.sequenceNumber),
            toMsgRef: new MessageRef(to.timestamp, to.sequenceNumber),
            publisherId,
            msgChainId,
        });
    }
    if (!request) {
        throw new Error(`Can't _requestResend without resend options. Got: ${util_1.inspect(resendOptions)}`);
    }
    return request;
}
async function resend(client, options) {
    const sessionToken = await client.session.getSessionToken();
    const request = createResendRequest({
        ...options,
        sessionToken,
    });
    const onResponse = utils_2.waitForRequestResponse(client, request);
    await client.send(request);
    return onResponse;
}
exports.resend = resend;
//# sourceMappingURL=api.js.map