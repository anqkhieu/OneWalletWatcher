"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.GroupKeyPersistence = void 0;
const Encryption_1 = require("./Encryption");
const ServerPersistentStore_1 = __importDefault(require("./ServerPersistentStore"));
class GroupKeyPersistence {
    constructor(options) {
        this.store = new ServerPersistentStore_1.default(options);
    }
    async has(groupKeyId) {
        return this.store.has(groupKeyId);
    }
    async size() {
        return this.store.size();
    }
    async get(groupKeyId) {
        const value = await this.store.get(groupKeyId);
        if (!value) {
            return undefined;
        }
        return Encryption_1.GroupKey.from([groupKeyId, value]);
    }
    async add(groupKey) {
        return this.set(groupKey.id, groupKey);
    }
    async set(groupKeyId, value) {
        Encryption_1.GroupKey.validate(value);
        return this.store.set(groupKeyId, value.hex);
    }
    async delete(groupKeyId) {
        return this.store.delete(groupKeyId);
    }
    async clear() {
        return this.store.clear();
    }
    async destroy() {
        return this.store.destroy();
    }
    async close() {
        return this.store.close();
    }
    async exists() {
        return this.store.exists();
    }
    get [Symbol.toStringTag]() {
        return this.constructor.name;
    }
}
exports.GroupKeyPersistence = GroupKeyPersistence;
class GroupKeyStore {
    constructor({ clientId, streamId, groupKeys }) {
        this.nextGroupKeys = []; // the keys to use next, disappears if not actually used. Max queue size 2
        const initialData = groupKeys.reduce((o, [, groupKey]) => Object.assign(o, {
            [groupKey.id]: groupKey.hex,
        }), {});
        this.store = new GroupKeyPersistence({ clientId, streamId, initialData });
        groupKeys.forEach(([groupKeyId, groupKey]) => {
            Encryption_1.GroupKey.validate(groupKey);
            if (groupKeyId !== groupKey.id) {
                throw new Error(`Ids must match: groupKey.id: ${groupKey.id}, groupKeyId: ${groupKeyId}`);
            }
            // use last init key as current
            this.currentGroupKeyId = groupKey.id;
        });
    }
    async storeKey(groupKey) {
        Encryption_1.GroupKey.validate(groupKey);
        const existingKey = await this.store.get(groupKey.id);
        if (existingKey) {
            if (!existingKey.equals(groupKey)) {
                throw new Encryption_1.GroupKey.InvalidGroupKeyError(`Trying to add groupKey ${groupKey.id} but key exists & is not equivalent to new GroupKey: ${groupKey}.`, groupKey);
            }
            await this.store.set(groupKey.id, existingKey);
            return existingKey;
        }
        await this.store.set(groupKey.id, groupKey);
        return groupKey;
    }
    async has(id) {
        if (this.currentGroupKeyId === id) {
            return true;
        }
        if (this.nextGroupKeys.some((nextKey) => nextKey.id === id)) {
            return true;
        }
        return this.store.has(id);
    }
    async isEmpty() {
        // any pending keys means it's not empty
        if (this.nextGroupKeys.length) {
            return false;
        }
        return (await this.store.size()) === 0;
    }
    async useGroupKey() {
        const nextGroupKey = this.nextGroupKeys.pop();
        // First use of group key on this stream, no current key. Make next key current.
        if (!this.currentGroupKeyId && nextGroupKey) {
            this.currentGroupKeyId = nextGroupKey.id;
            return [
                await this.get(this.currentGroupKeyId),
                undefined,
            ];
        }
        // Keep using current key (empty next)
        if (this.currentGroupKeyId != null && !nextGroupKey) {
            return [
                await this.get(this.currentGroupKeyId),
                undefined
            ];
        }
        // Key changed (non-empty next). return current + next. Make next key current.
        if (this.currentGroupKeyId != null && nextGroupKey != null) {
            const prevId = this.currentGroupKeyId;
            this.currentGroupKeyId = nextGroupKey.id;
            const prevGroupKey = await this.get(prevId);
            // use current key one more time
            return [
                prevGroupKey,
                nextGroupKey,
            ];
        }
        // Generate & use new key if none already set.
        await this.rotateGroupKey();
        return this.useGroupKey();
    }
    async get(id) {
        return this.store.get(id);
    }
    async exists() {
        return this.store.exists();
    }
    async clear() {
        this.currentGroupKeyId = undefined;
        this.nextGroupKeys.length = 0;
        return this.store.clear();
    }
    async rotateGroupKey() {
        return this.setNextGroupKey(Encryption_1.GroupKey.generate());
    }
    async add(groupKey) {
        return this.storeKey(groupKey);
    }
    async setNextGroupKey(newKey) {
        Encryption_1.GroupKey.validate(newKey);
        this.nextGroupKeys.unshift(newKey);
        this.nextGroupKeys.length = Math.min(this.nextGroupKeys.length, 2);
        await this.storeKey(newKey);
    }
    async close() {
        return this.store.close();
    }
    async rekey() {
        const newKey = Encryption_1.GroupKey.generate();
        await this.storeKey(newKey);
        this.currentGroupKeyId = newKey.id;
        this.nextGroupKeys.length = 0;
    }
}
exports.default = GroupKeyStore;
//# sourceMappingURL=GroupKeyStore.js.map