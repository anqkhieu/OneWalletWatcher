"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const streamr_client_protocol_1 = require("streamr-client-protocol");
const Encryption_1 = __importStar(require("../stream/encryption/Encryption"));
const KeyExchangeSubscriber_1 = require("../stream/encryption/KeyExchangeSubscriber");
const { StreamMessage } = streamr_client_protocol_1.MessageLayer;
function Decrypt(client, options = {}) {
    if (!client.options.keyExchange) {
        // noop unless message encrypted
        return (streamMessage) => {
            if (streamMessage.groupKeyId) {
                throw new Encryption_1.UnableToDecryptError('No keyExchange configured, cannot decrypt any message.', streamMessage);
            }
            return streamMessage;
        };
    }
    const keyExchange = new KeyExchangeSubscriber_1.SubscriberKeyExchange(client, {
        ...options,
        groupKeys: {
            ...client.options.groupKeys,
            ...options.groupKeys,
        }
    });
    async function* decrypt(src, onError = async () => { }) {
        for await (const streamMessage of src) {
            if (!streamMessage.groupKeyId) {
                yield streamMessage;
                continue;
            }
            if (streamMessage.encryptionType !== StreamMessage.ENCRYPTION_TYPES.AES) {
                yield streamMessage;
                continue;
            }
            try {
                const groupKey = await keyExchange.getGroupKey(streamMessage).catch((err) => {
                    throw new Encryption_1.UnableToDecryptError(`Could not get GroupKey: ${streamMessage.groupKeyId} â€“ ${err.stack}`, streamMessage);
                });
                if (!groupKey) {
                    throw new Encryption_1.UnableToDecryptError([
                        `Could not get GroupKey: ${streamMessage.groupKeyId}`,
                        'Publisher is offline, key does not exist or no permission to access key.',
                    ].join(' '), streamMessage);
                }
                await Encryption_1.default.decryptStreamMessage(streamMessage, groupKey);
                await keyExchange.addNewKey(streamMessage);
            }
            catch (err) {
                // clear cached permissions if cannot decrypt, likely permissions need updating
                client.cached.clearStream(streamMessage.getStreamId());
                await onError(err, streamMessage);
            }
            finally {
                yield streamMessage;
            }
        }
    }
    return Object.assign(decrypt, {
        async stop() {
            return keyExchange.stop();
        }
    });
}
exports.default = Decrypt;
//# sourceMappingURL=Decrypt.js.map