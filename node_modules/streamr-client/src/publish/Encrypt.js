"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const streamr_client_protocol_1 = require("streamr-client-protocol");
const Encryption_1 = __importDefault(require("../stream/encryption/Encryption"));
const KeyExchangePublisher_1 = require("../stream/encryption/KeyExchangePublisher");
const { StreamMessage } = streamr_client_protocol_1.MessageLayer;
function Encrypt(client) {
    let publisherKeyExchange;
    function getPublisherKeyExchange() {
        if (!publisherKeyExchange) {
            publisherKeyExchange = new KeyExchangePublisher_1.PublisherKeyExchange(client, {
                groupKeys: {
                    ...client.options.groupKeys,
                }
            });
        }
        return publisherKeyExchange;
    }
    async function encrypt(streamMessage, stream) {
        if (!client.canEncrypt()) {
            return;
        }
        const { messageType } = streamMessage;
        if (messageType === StreamMessage.MESSAGE_TYPES.GROUP_KEY_RESPONSE
            || messageType === StreamMessage.MESSAGE_TYPES.GROUP_KEY_REQUEST
            || messageType === StreamMessage.MESSAGE_TYPES.GROUP_KEY_ERROR_RESPONSE) {
            // never encrypt
            return;
        }
        if (!stream.requireEncryptedData
            && !(await (getPublisherKeyExchange().hasAnyGroupKey(stream.id)))) {
            // not needed
            return;
        }
        if (streamMessage.messageType !== StreamMessage.MESSAGE_TYPES.MESSAGE) {
            return;
        }
        const [groupKey, nextGroupKey] = await getPublisherKeyExchange().useGroupKey(stream.id);
        if (!groupKey) {
            throw new Error(`Tried to use group key but no group key found for stream: ${stream.id}`);
        }
        await Encryption_1.default.encryptStreamMessage(streamMessage, groupKey, nextGroupKey);
    }
    return Object.assign(encrypt, {
        setNextGroupKey(...args) {
            return getPublisherKeyExchange().setNextGroupKey(...args);
        },
        rotateGroupKey(...args) {
            return getPublisherKeyExchange().rotateGroupKey(...args);
        },
        rekey(...args) {
            return getPublisherKeyExchange().rekey(...args);
        },
        start() {
            return getPublisherKeyExchange().start();
        },
        async stop() {
            if (!publisherKeyExchange) {
                return;
            }
            const exchange = publisherKeyExchange;
            publisherKeyExchange = undefined;
            await exchange.stop();
        }
    });
}
exports.default = Encrypt;
//# sourceMappingURL=Encrypt.js.map