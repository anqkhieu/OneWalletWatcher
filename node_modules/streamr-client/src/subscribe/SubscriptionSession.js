"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const events_1 = __importDefault(require("events"));
const utils_1 = require("../utils");
const utils_2 = require("../stream/utils");
const Connection_1 = require("../Connection");
const api_1 = require("./api");
const Validator_1 = __importDefault(require("./Validator"));
/**
 * Emit event on all supplied emitters.
 * Aggregates errors rather than throwing on first.
 */
function multiEmit(emitters, ...args) {
    let error;
    emitters.forEach((s) => {
        try {
            s.emit(...args);
        }
        catch (err) {
            utils_1.AggregatedError.from(error, err, `Error emitting event: ${args[0]}`);
        }
    });
    if (error) {
        throw error;
    }
}
/**
 * Sends Subscribe/Unsubscribe requests as needed.
 * Adds connection handles as needed.
 */
class SubscriptionSession extends events_1.default {
    constructor(client, options) {
        super();
        /** active subs */
        this.subscriptions = new Set();
        this.pendingRemoval = new Set();
        this.client = client;
        this.options = utils_2.validateOptions(options);
        this.validate = Validator_1.default(client, this.options);
        this._subscribe = this.options.subscribe || api_1.subscribe;
        this._unsubscribe = this.options.unsubscribe || api_1.unsubscribe;
        this.id = utils_1.counterId(`SubscriptionSession:${this.options.id || ''}${this.options.key}`);
        this.debug = this.client.debug.extend(this.id);
        this.debug('create');
        this._init();
    }
    _init() {
        const { key } = this.options;
        let needsReset = false;
        const onDisconnected = async () => {
            const { connection } = this.client;
            // see if we should reset then retry connecting
            try {
                if (!connection.isConnectionValid()) {
                    await this.updateSubscriptions();
                    return;
                }
                needsReset = true;
                await this.updateSubscriptions();
                if (connection.isConnectionValid()) {
                    needsReset = false;
                    await this.updateSubscriptions();
                }
            }
            catch (err) {
                this.emit('error', err);
            }
        };
        const check = () => {
            const { connection } = this.client;
            return !!(connection.isConnectionValid()
                && !needsReset
                // has some active subscription
                && this.count());
        };
        this.updateSubscriptions = utils_1.Scaffold([
            () => {
                if (!needsReset) {
                    this.emit('subscribing');
                }
                needsReset = false;
                // add handlers for connection close events
                const { connection } = this.client;
                connection.on('done', onDisconnected);
                connection.on('disconnected', onDisconnected);
                connection.on('disconnecting', onDisconnected);
                return () => {
                    connection.off('done', onDisconnected);
                    connection.off('disconnected', onDisconnected);
                    connection.off('disconnecting', onDisconnected);
                };
            },
            // open connection
            async () => {
                const { connection } = this.client;
                await connection.addHandle(key);
                return async () => {
                    if (needsReset) {
                        return;
                    } // don't close connection if just resetting
                    await connection.removeHandle(key);
                };
            },
            // validate connected
            async () => {
                const { connection } = this.client;
                await connection.needsConnection(`Subscribe ${key}`);
            },
            // subscribe
            async () => {
                await this._subscribe(this.client, this.options);
                return async () => {
                    if (needsReset) {
                        return;
                    }
                    await this._unsubscribe(this.client, this.options);
                };
            }
        ], check, {
            onChange: (isGoingUp) => {
                if (needsReset) {
                    return;
                }
                if (!isGoingUp) {
                    this.emit('unsubscribing');
                }
            },
            onDone: async (isGoingUp) => {
                if (needsReset) {
                    return;
                }
                if (isGoingUp) {
                    this.emit('subscribed');
                }
                else {
                    this.emit('unsubscribed');
                    const { connection } = this.client;
                    if (!connection.isConnectionValid()) {
                        await this.removeAll();
                    }
                }
            },
            onError: (err) => {
                this.debug('error', err);
                if (err instanceof Connection_1.ConnectionError && !check()) {
                    // ignore error if state changed
                    needsReset = true;
                    return;
                }
                throw err;
            }
        });
    }
    has(sub) {
        return this.subscriptions.has(sub);
    }
    /**
     * Emit message on every subscription,
     * then on self.
     */
    emit(event, ...args) {
        const subs = this.subscriptions;
        if (event === 'error') {
            this.debug('emit', event, ...args);
        }
        else {
            this.debug('emit', event);
        }
        try {
            multiEmit(subs, event, ...args);
        }
        catch (error) {
            return super.emit('error', error);
        }
        return super.emit(event, ...args);
    }
    /**
     * Add subscription & appropriate connection handle.
     */
    async add(sub) {
        if (!sub || this.subscriptions.has(sub) || this.pendingRemoval.has(sub)) {
            return;
        } // already has
        const { id } = sub;
        this.subscriptions.add(sub);
        this.debug('add >>', id);
        const { connection } = this.client;
        await connection.addHandle(`adding${id}`);
        try {
            await connection.needsConnection(`Subscribe ${id}`);
            await this.updateSubscriptions();
        }
        finally {
            await connection.removeHandle(`adding${id}`);
            sub.emit('subscribed');
            this.debug('add <<', id);
        }
    }
    /**
     * Remove subscription & appropriate connection handle.
     */
    async remove(sub) {
        if (!sub || this.pendingRemoval.has(sub) || !this.subscriptions.has(sub)) {
            return;
        }
        const { id } = sub;
        this.debug('remove >>', id);
        this.pendingRemoval.add(sub);
        this.subscriptions.delete(sub);
        sub.emit('unsubscribing');
        try {
            await sub.cancel();
        }
        finally {
            try {
                await this.updateSubscriptions();
            }
            finally {
                this.pendingRemoval.delete(sub);
                this.debug('remove <<', id);
            }
        }
    }
    /**
     * Remove all subscriptions & subscription connection handles
     */
    async removeAll() {
        await Promise.all([...this.subscriptions].map((sub) => (this.remove(sub))));
    }
    /**
     * How many subscriptions
     */
    count() {
        return this.subscriptions.size;
    }
}
exports.default = SubscriptionSession;
//# sourceMappingURL=SubscriptionSession.js.map