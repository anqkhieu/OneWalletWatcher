"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PublisherKeyExchange = void 0;
const streamr_client_protocol_1 = require("streamr-client-protocol");
const p_memoize_1 = __importDefault(require("p-memoize"));
const utils_1 = require("../../utils");
const utils_2 = require("../utils");
const Encryption_1 = __importDefault(require("./Encryption"));
const GroupKeyStore_1 = __importDefault(require("./GroupKeyStore"));
const KeyExchangeUtils_1 = require("./KeyExchangeUtils");
const { ValidationError } = streamr_client_protocol_1.Errors;
class InvalidGroupKeyRequestError extends ValidationError {
    constructor(...args) {
        super(...args);
        this.code = 'INVALID_GROUP_KEY_REQUEST';
        if (Error.captureStackTrace) {
            Error.captureStackTrace(this, this.constructor);
        }
    }
}
async function catchKeyExchangeError(client, streamMessage, fn) {
    try {
        return await fn();
    }
    catch (error) {
        const subscriberId = streamMessage.getPublisherId();
        const msg = streamMessage.getParsedContent();
        const { streamId, requestId, groupKeyIds } = streamr_client_protocol_1.GroupKeyRequest.fromArray(msg);
        return client.publish(KeyExchangeUtils_1.getKeyExchangeStreamId(subscriberId), new streamr_client_protocol_1.GroupKeyErrorResponse({
            requestId,
            streamId,
            errorCode: error.code || 'UNEXPECTED_ERROR',
            errorMessage: error.message,
            groupKeyIds
        }));
    }
}
async function PublisherKeyExchangeSubscription(client, getGroupKeyStore) {
    async function onKeyExchangeMessage(_parsedContent, streamMessage) {
        return catchKeyExchangeError(client, streamMessage, async () => {
            if (streamMessage.messageType !== streamr_client_protocol_1.StreamMessage.MESSAGE_TYPES.GROUP_KEY_REQUEST) {
                return;
            }
            // No need to check if parsedContent contains the necessary fields because it was already checked during deserialization
            const { requestId, streamId, rsaPublicKey, groupKeyIds } = streamr_client_protocol_1.GroupKeyRequest.fromArray(streamMessage.getParsedContent());
            const subscriberId = streamMessage.getPublisherId();
            const groupKeyStore = await getGroupKeyStore(streamId);
            const isSubscriber = await client.isStreamSubscriber(streamId, subscriberId);
            const encryptedGroupKeys = (!isSubscriber ? [] : await Promise.all(groupKeyIds.map(async (id) => {
                const groupKey = await groupKeyStore.get(id);
                if (!groupKey) {
                    return null; // will be filtered out
                }
                const key = Encryption_1.default.encryptWithPublicKey(groupKey.data, rsaPublicKey, true);
                return new streamr_client_protocol_1.EncryptedGroupKey(id, key);
            }))).filter(Boolean);
            client.debug('Publisher: Subscriber requested groupKeys: %d. Got: %d. %o', groupKeyIds.length, encryptedGroupKeys.length, {
                subscriberId,
                groupKeyIds,
                responseKeys: encryptedGroupKeys.map(({ groupKeyId }) => groupKeyId),
            });
            const response = new streamr_client_protocol_1.GroupKeyResponse({
                streamId,
                requestId,
                encryptedGroupKeys,
            });
            // hack overriding toStreamMessage method to set correct encryption type
            const toStreamMessage = response.toStreamMessage.bind(response);
            response.toStreamMessage = (...args) => {
                const msg = toStreamMessage(...args);
                msg.encryptionType = streamr_client_protocol_1.StreamMessage.ENCRYPTION_TYPES.RSA;
                return msg;
            };
            await client.publish(KeyExchangeUtils_1.getKeyExchangeStreamId(subscriberId), response);
        });
    }
    const sub = await KeyExchangeUtils_1.subscribeToKeyExchangeStream(client, onKeyExchangeMessage);
    if (!sub) {
        return undefined;
    }
    sub.on('error', (err) => {
        if (!('streamMessage' in err)) {
            return; // do nothing
        }
        // wrap error and translate into ErrorResponse.
        catchKeyExchangeError(client, err.streamMessage, () => {
            // rethrow so catchKeyExchangeError handles it
            throw new InvalidGroupKeyRequestError(err.message);
        }).catch((unexpectedError) => {
            sub.emit('error', unexpectedError);
        });
    });
    return sub;
}
class PublisherKeyExchange {
    constructor(client, { groupKeys = {} } = {}) {
        this.enabled = true;
        this.client = client;
        this.initialGroupKeys = groupKeys;
        this.cleanupFns = [];
        this.getSub = utils_1.pOne(this.getSub.bind(this));
        this.getGroupKeyStore = p_memoize_1.default(this.getGroupKeyStore.bind(this), {
            cacheKey([maybeStreamId]) {
                const { streamId } = utils_2.validateOptions(maybeStreamId);
                return streamId;
            }
        });
    }
    async getSub() {
        if (!this.enabled) {
            if (this.sub) {
                await this.sub.cancel();
            }
            if (this.getSubTask) {
                return this.getSubTask;
            }
            return undefined;
        }
        if (this.sub) {
            return this.sub;
        }
        if (this.getSubTask) {
            return this.getSubTask;
        }
        this.getSubTask = PublisherKeyExchangeSubscription(this.client, this.getGroupKeyStore).finally(() => {
            this.getSubTask = undefined;
        }).then(async (sub) => {
            if (!this.enabled && sub) {
                await sub.cancel();
                return undefined;
            }
            this.sub = sub;
            return sub;
        });
        return this.getSubTask;
    }
    async getGroupKeyStore(streamId) {
        const clientId = await this.client.getAddress();
        const store = new GroupKeyStore_1.default({
            clientId,
            streamId,
            groupKeys: [...KeyExchangeUtils_1.parseGroupKeys(this.initialGroupKeys[streamId]).entries()]
        });
        this.cleanupFns.push(async () => {
            try {
                await store.close();
            }
            catch (_err) {
                // whatever
            }
        });
        return store;
    }
    async rotateGroupKey(streamId) {
        if (!this.enabled) {
            return;
        }
        const groupKeyStore = await this.getGroupKeyStore(streamId);
        await groupKeyStore.rotateGroupKey();
    }
    async setNextGroupKey(streamId, groupKey) {
        if (!this.enabled) {
            return;
        }
        const groupKeyStore = await this.getGroupKeyStore(streamId);
        await groupKeyStore.setNextGroupKey(groupKey);
    }
    async useGroupKey(streamId) {
        await this.getSub();
        if (!this.enabled) {
            return [];
        }
        const groupKeyStore = await this.getGroupKeyStore(streamId);
        return groupKeyStore.useGroupKey();
    }
    async hasAnyGroupKey(streamId) {
        const groupKeyStore = await this.getGroupKeyStore(streamId);
        return !(await groupKeyStore.isEmpty());
    }
    async rekey(streamId) {
        if (!this.enabled) {
            return;
        }
        const groupKeyStore = await this.getGroupKeyStore(streamId);
        if (!this.enabled) {
            return;
        }
        await groupKeyStore.rekey();
        if (!this.enabled) {
            return;
        }
        await this.getSub();
    }
    async start() {
        this.enabled = true;
        await this.getSub();
    }
    async stop() {
        p_memoize_1.default.clear(this.getGroupKeyStore);
        this.enabled = false;
        await this.getSub();
        const { cleanupFns } = this;
        this.cleanupFns = [];
        await Promise.allSettled(cleanupFns);
    }
}
exports.PublisherKeyExchange = PublisherKeyExchange;
//# sourceMappingURL=KeyExchangePublisher.js.map