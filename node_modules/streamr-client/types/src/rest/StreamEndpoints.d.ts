import { Stream, StreamOperation, StreamProperties } from '../stream';
import { StreamPart } from '../stream/StreamPart';
import { EthereumAddress } from '../types';
import { StreamrClient } from '../StreamrClient';
import { ContentType, EncryptionType, SignatureType, StreamMessageType } from 'streamr-client-protocol/dist/src/protocol/message_layer/StreamMessage';
import { StorageNode } from '../stream/StorageNode';
export interface StreamListQuery {
    name?: string;
    uiChannel?: boolean;
    noConfig?: boolean;
    search?: string;
    sortBy?: string;
    order?: 'asc' | 'desc';
    max?: number;
    offset?: number;
    grantedAccess?: boolean;
    publicAccess?: boolean;
    operation?: StreamOperation;
}
export interface StreamValidationInfo {
    partitions: number;
    requireSignedData: boolean;
    requireEncryptedData: boolean;
}
export interface StreamMessageAsObject {
    streamId: string;
    streamPartition: number;
    timestamp: number;
    sequenceNumber: number;
    publisherId: string;
    msgChainId: string;
    messageType: StreamMessageType;
    contentType: ContentType;
    encryptionType: EncryptionType;
    groupKeyId: string | null;
    content: any;
    signatureType: SignatureType;
    signature: string | null;
}
/** TODO the class should be annotated with at-internal, but adding the annotation hides the methods */
export declare class StreamEndpoints {
    constructor(client: StreamrClient);
    /**
     * @category Important
     */
    getStream(streamId: string): Promise<Stream>;
    /**
     * @category Important
     */
    listStreams(query?: StreamListQuery): Promise<Stream[]>;
    getStreamByName(name: string): Promise<Stream>;
    /**
     * @category Important
     * @param props - if id is specified, it can be full streamId or path
     */
    createStream(props?: Partial<StreamProperties> & {
        id: string;
    }): Promise<Stream>;
    /**
     * @category Important
     */
    getOrCreateStream(props: {
        id: string;
        name?: never;
    } | {
        id?: never;
        name: string;
    }): Promise<Stream>;
    getStreamPublishers(streamId: string): Promise<string[]>;
    isStreamPublisher(streamId: string, ethAddress: EthereumAddress): Promise<boolean>;
    getStreamSubscribers(streamId: string): Promise<string[]>;
    isStreamSubscriber(streamId: string, ethAddress: EthereumAddress): Promise<boolean>;
    getStreamValidationInfo(streamId: string): Promise<StreamValidationInfo>;
    getStreamLast(streamObjectOrId: Stream | string): Promise<StreamMessageAsObject>;
    getStreamPartsByStorageNode(node: StorageNode | EthereumAddress): Promise<StreamPart[]>;
    publishHttp(streamObjectOrId: Stream | string, data: any, requestOptions?: any, keepAlive?: boolean): Promise<void>;
}
