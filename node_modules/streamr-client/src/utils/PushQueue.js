"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AbortError = void 0;
const index_1 = require("./index");
async function endGenerator(gtr, error) {
    return error
        ? gtr.throw(error).catch(() => { }) // ignore err
        : gtr.return(undefined);
}
async function endGeneratorTimeout(gtr, { timeout = 250, error, } = {}) {
    return index_1.pTimeout(endGenerator(gtr, error), {
        timeout,
        rejectOnTimeout: false,
    });
}
class AbortError extends Error {
    constructor(msg = '') {
        super(`The operation was aborted. ${msg}`);
        if (Error.captureStackTrace) {
            Error.captureStackTrace(this, this.constructor);
        }
    }
}
exports.AbortError = AbortError;
class PushQueue {
    constructor(items = [], { signal, onEnd, timeout = 0, autoEnd = true } = {}) {
        this.nextQueue = []; // queued promises for next()
        this.finished = false;
        this.pending = 0;
        this.ended = false;
        this._onEndCalled = false;
        this._isCancelled = false;
        this.autoEnd = autoEnd;
        this.timeout = timeout;
        this._onEnd = onEnd;
        this.buffer = [...items];
        this[Symbol.asyncIterator] = this[Symbol.asyncIterator].bind(this);
        this.onAbort = this.onAbort.bind(this);
        this.onEnd = this.onEnd.bind(this);
        this.cancel = this.cancel.bind(this);
        this.isCancelled = this.isCancelled.bind(this);
        this.end = this.end.bind(this);
        // abort signal handling
        if (signal) {
            this.signal = signal;
            if (signal.aborted) {
                this.onAbort();
            }
            signal.addEventListener('abort', this.onAbort, {
                once: true
            });
        }
        this.iterator = this.iterate();
    }
    static from(iterable, opts = {}) {
        const queue = new PushQueue([], opts);
        queue.from(iterable);
        return queue;
    }
    static transform(src, fn, opts = {}) {
        const buffer = new PushQueue([], opts);
        (async () => {
            for await (const value of src) {
                buffer.push(fn(value));
            }
            if (buffer.autoEnd) {
                buffer.end();
            }
        })().catch((err) => {
            return buffer.throw(err);
        }); // no await
        return buffer;
    }
    async from(iterable, { end = this.autoEnd } = {}) {
        try {
            // detect sync/async iterable and iterate appropriately
            if ((Symbol.asyncIterator || Symbol.for('Symbol.asyncIterator')) in iterable) {
                for await (const item of iterable) {
                    this.push(item);
                }
            }
            else if ((Symbol.iterator || Symbol.for('Symbol.iterator')) in iterable) {
                // sync iterables push into buffer immediately
                for (const item of iterable) {
                    this.push(item);
                }
            }
        }
        catch (err) {
            return this.throw(err);
        }
        if (end) {
            this.end();
        }
        return Promise.resolve();
    }
    onEnd(err, ...args) {
        if (this._onEndCalled || !this._onEnd) {
            return Promise.resolve();
        }
        this._onEndCalled = true;
        return this._onEnd(err, ...args);
    }
    /**
     * signals no more data should be buffered
     */
    end(v) {
        if (this.ended) {
            return;
        }
        if (v != null) {
            this.push(v);
        }
        this.push(null);
        this.ended = true;
    }
    onAbort() {
        return this.throw(new AbortError());
    }
    async next(...args) {
        return this.iterator.next(...args);
    }
    isWritable() {
        return !(this.finished || this.ended);
    }
    isReadable() {
        return !(this.finished || this.ended);
    }
    async return() {
        this.finished = true;
        await this._cleanup();
    }
    async throw(err) {
        if (this.finished) {
            return;
        }
        this.finished = true;
        const p = this.nextQueue.shift();
        if (p) {
            p.reject(err);
        }
        else {
            // for next()
            this.error = err;
        }
    }
    get length() {
        const count = this.pending + this.buffer.length;
        return this.ended && count ? count - 1 : count;
    }
    async _cleanup() {
        // capture error and pending next promises
        const { error, nextQueue } = this;
        this.finished = true;
        this.error = undefined;
        this.pending = 0;
        // empty buffer then reassign
        this.buffer.length = 0;
        this.buffer = [];
        // reassign nextQueue, emptying would mutate value we captured
        this.nextQueue = [];
        const doneValue = { value: undefined, done: true };
        // resolve all pending next promises
        while (nextQueue.length) {
            const p = nextQueue.shift();
            if (!p) {
                continue;
            }
            if (error) {
                p.reject(error);
            }
            else {
                p.resolve(doneValue);
            }
        }
        return this.onEnd(error);
    }
    push(...values) {
        if (this.finished || this.ended) {
            // do nothing if done
            return;
        }
        // if values contains null, treat null as end
        const nullIndex = values.findIndex((v) => v === null);
        let validValues = values;
        if (nullIndex !== -1) {
            this.ended = true;
            // include null but trim rest
            validValues = values.slice(0, nullIndex + 1);
        }
        // resolve pending next calls
        while (this.nextQueue.length && validValues.length) {
            const p = this.nextQueue.shift();
            if (p) {
                p.resolve(validValues.shift());
            }
        }
        // push any remaining values into buffer
        if (validValues.length) {
            this.buffer.push(...validValues);
        }
    }
    iterate() {
        const handleTerminalValues = (value) => {
            // returns final task to perform before returning, or false
            if (value === null) {
                return this.return();
            }
            if (value instanceof Error) {
                return this.throw(value);
            }
            return false;
        };
        return async function* iterate() {
            while (true) {
                /* eslint-disable no-await-in-loop */
                // feed from buffer first
                const buffer = this.buffer.slice();
                this.pending += buffer.length;
                this.buffer.length = 0; // prevent endless loop
                while (buffer.length && !this.error && !this.finished) {
                    this.pending = Math.max(this.pending - 1, 0);
                    const value = buffer.shift();
                    const endTask = handleTerminalValues(value);
                    if (endTask) {
                        await endTask;
                        break;
                    }
                    yield value;
                }
                // handle queued error
                if (this.error) {
                    const err = this.error;
                    this.error = undefined;
                    throw err;
                }
                // done
                if (this.finished) {
                    return;
                }
                // if more items have been buffered, continue loop
                if (this.buffer.length) {
                    continue; // eslint-disable-line no-continue
                }
                const deferred = index_1.Defer();
                this.nextQueue.push(deferred);
                deferred.catch(() => { }); // prevent unhandledrejection
                const value = await deferred;
                // ignore value if finished
                if (this.finished) {
                    return;
                }
                const endTask = handleTerminalValues(value);
                if (endTask) {
                    await endTask;
                    continue; // eslint-disable-line no-continue
                }
                yield value;
                /* eslint-enable no-await-in-loop */
            }
        }.call(this);
    }
    pipe(next, opts) {
        return next.from(this, opts);
    }
    async cancel(error) {
        this.finished = true;
        this._isCancelled = true;
        if (error) {
            this.error = error;
        }
        await endGeneratorTimeout(this.iterator, {
            timeout: this.timeout,
            error,
        });
        return this.return();
    }
    isCancelled() {
        return this._isCancelled;
    }
    async *[Symbol.asyncIterator]() {
        // NOTE: consider throwing if trying to iterate after finished
        // or maybe returning a new iterator?
        try {
            yield* this.iterator;
        }
        finally {
            this._cleanup();
            this.finished = true;
            if (this.signal) {
                this.signal.removeEventListener('abort', this.onAbort);
            }
            await this.onEnd(this.error);
        }
    }
}
exports.default = PushQueue;
//# sourceMappingURL=PushQueue.js.map