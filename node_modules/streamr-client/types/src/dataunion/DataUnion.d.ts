import { BigNumber } from '@ethersproject/bignumber';
import { ContractReceipt } from '@ethersproject/contracts';
import type { Overrides as EthersOptions } from '@ethersproject/contracts';
import { EthereumAddress } from '../types';
export interface DataUnionDeployOptions {
    owner?: EthereumAddress;
    joinPartAgents?: EthereumAddress[];
    dataUnionName?: string;
    adminFee?: number;
    sidechainPollingIntervalMs?: number;
    sidechainRetryTimeoutMs?: number;
    confirmations?: number;
    gasPrice?: BigNumber;
}
export declare enum JoinRequestState {
    PENDING = "PENDING",
    ACCEPTED = "ACCEPTED",
    REJECTED = "REJECTED"
}
export interface JoinResponse {
    id: string;
    state: JoinRequestState;
}
export interface DataUnionWithdrawOptions {
    pollingIntervalMs?: number;
    retryTimeoutMs?: number;
    payForTransport?: boolean;
    waitUntilTransportIsComplete?: boolean;
    sendToMainnet?: boolean;
    gasPrice?: BigNumber | string;
}
export interface DataUnionStats {
    activeMemberCount: BigNumber;
    inactiveMemberCount: BigNumber;
    joinPartAgentCount: BigNumber;
    totalEarnings: BigNumber;
    totalWithdrawable: BigNumber;
    lifetimeMemberEarnings: BigNumber;
}
export declare enum MemberStatus {
    ACTIVE = "ACTIVE",
    INACTIVE = "INACTIVE",
    NONE = "NONE"
}
export interface MemberStats {
    status: MemberStatus;
    earningsBeforeLastJoin: BigNumber;
    totalEarnings: BigNumber;
    withdrawableEarnings: BigNumber;
}
export declare type AmbMessageHash = string;
/**
 * @category Important
 */
export declare class DataUnion {
    private contractAddress;
    private sidechainAddress;
    private client;
    getAddress(): string;
    getSidechainAddress(): string;
    /**
     * Send a joinRequest, or get into data union instantly with a data union secret
     */
    join(secret?: string): Promise<JoinResponse>;
    /**
     * Voluntarily leave the Data Union
     * @returns side-chain transaction receipt
     */
    part(): Promise<ContractReceipt>;
    isMember(memberAddress: EthereumAddress): Promise<boolean>;
    /**
     * Withdraw all your earnings
     * @returns the sidechain withdraw transaction receipt IF called with sendToMainnet=false,
     *          ELSE the message hash IF called with payForTransport=false and waitUntilTransportIsComplete=false,
     *          ELSE the mainnet AMB signature execution transaction receipt IF we did the transport ourselves,
     *          ELSE null IF transport to mainnet was done by someone else (in which case the receipt is lost)
     */
    withdrawAll(options?: DataUnionWithdrawOptions): Promise<string | ContractReceipt | null>;
    /**
     * Get the tx promise for withdrawing all your earnings
     * @returns await on call .wait to actually send the tx
     */
    private getWithdrawAllTx;
    /**
     * Withdraw earnings and "donate" them to the given address
     * @returns the sidechain withdraw transaction receipt IF called with sendToMainnet=false,
     *          ELSE the message hash IF called with payForTransport=false and waitUntilTransportIsComplete=false,
     *          ELSE the mainnet AMB signature execution transaction receipt IF we did the transport ourselves,
     *          ELSE null IF transport to mainnet was done by someone else (in which case the receipt is lost)
     */
    withdrawAllTo(recipientAddress: EthereumAddress, options?: DataUnionWithdrawOptions): Promise<string | ContractReceipt | null>;
    /**
     * Withdraw earnings and "donate" them to the given address
     * @param recipientAddress - the address to receive the tokens
     * @returns await on call .wait to actually send the tx
     */
    private getWithdrawAllToTx;
    /**
     * Member can sign off to "donate" all earnings to another address such that someone else
     *   can submit the transaction (and pay for the gas)
     * This signature is only valid until next withdrawal takes place (using this signature or otherwise).
     * Note that while it's a "blank cheque" for withdrawing all earnings at the moment it's used, it's
     *   invalidated by the first withdraw after signing it. In other words, any signature can be invalidated
     *   by making a "normal" withdraw e.g. `await streamrClient.withdrawAll()`
     * Admin can execute the withdraw using this signature: ```
     *   await adminStreamrClient.withdrawAllToSigned(memberAddress, recipientAddress, signature)
     * ```
     * @param recipientAddress - the address authorized to receive the tokens
     * @returns signature authorizing withdrawing all earnings to given recipientAddress
     */
    signWithdrawAllTo(recipientAddress: EthereumAddress): Promise<string>;
    /**
     * Member can sign off to "donate" specific amount of earnings to another address such that someone else
     *   can submit the transaction (and pay for the gas)
     * This signature is only valid until next withdrawal takes place (using this signature or otherwise).
     * @param recipientAddress - the address authorized to receive the tokens
     * @param amountTokenWei - that the signature is for (can't be used for less or for more)
     * @returns signature authorizing withdrawing all earnings to given recipientAddress
     */
    signWithdrawAmountTo(recipientAddress: EthereumAddress, amountTokenWei: BigNumber | number | string): Promise<string>;
    signSetBinanceRecipient(recipientAddress: EthereumAddress): Promise<string>;
    getStats(): Promise<DataUnionStats>;
    /**
     * Get stats of a single data union member
     */
    getMemberStats(memberAddress: EthereumAddress): Promise<MemberStats>;
    /**
     * Get the amount of tokens the member would get from a successful withdraw
     */
    getWithdrawableEarnings(memberAddress: EthereumAddress): Promise<BigNumber>;
    /**
     * Get data union admin fee fraction (between 0.0 and 1.0) that admin gets from each revenue event
     */
    getAdminFee(): Promise<number>;
    getAdminAddress(): Promise<EthereumAddress>;
    /**
     * Figure out if given mainnet address is old DataUnion (v 1.0) or current 2.0
     * NOTE: Current version of streamr-client-javascript can only handle current version!
     */
    getVersion(): Promise<number>;
    /**
     * Add a new data union secret
     */
    createSecret(name?: string): Promise<string>;
    /**
     * Add given Ethereum addresses as data union members
     */
    addMembers(memberAddressList: EthereumAddress[]): Promise<ContractReceipt>;
    /**
     * Remove given members from data union
     */
    removeMembers(memberAddressList: EthereumAddress[]): Promise<ContractReceipt>;
    /**
     * Admin: withdraw earnings (pay gas) on behalf of a member
     * TODO: add test
     * @param memberAddress - the other member who gets their tokens out of the Data Union
     * @returns the sidechain withdraw transaction receipt IF called with sendToMainnet=false,
     *          ELSE the message hash IF called with payForTransport=false and waitUntilTransportIsComplete=false,
     *          ELSE the mainnet AMB signature execution transaction receipt IF we did the transport ourselves,
     *          ELSE null IF transport to mainnet was done by someone else (in which case the receipt is lost)
     */
    withdrawAllToMember(memberAddress: EthereumAddress, options?: DataUnionWithdrawOptions): Promise<string | ContractReceipt | null>;
    withdrawAllToBinance(options?: DataUnionWithdrawOptions): Promise<string | ContractReceipt | null>;
    signWithdrawAllToBinance(): Promise<string>;
    /**
     * Admin: get the tx promise for withdrawing all earnings on behalf of a member
     * @param memberAddress - the other member who gets their tokens out of the Data Union
     * @returns await on call .wait to actually send the tx
     */
    private getWithdrawAllToMemberTx;
    /**
     * Admin: Withdraw a member's earnings to another address, signed by the member
     * @param memberAddress - the member whose earnings are sent out
     * @param recipientAddress - the address to receive the tokens in mainnet
     * @param signature - from member, produced using signWithdrawAllTo
     * @returns the sidechain withdraw transaction receipt IF called with sendToMainnet=false,
     *          ELSE the message hash IF called with payForTransport=false and waitUntilTransportIsComplete=false,
     *          ELSE the mainnet AMB signature execution transaction receipt IF we did the transport ourselves,
     *          ELSE null IF transport to mainnet was done by someone else (in which case the receipt is lost)
     */
    withdrawAllToSigned(memberAddress: EthereumAddress, recipientAddress: EthereumAddress, signature: string, options?: DataUnionWithdrawOptions): Promise<string | ContractReceipt | null>;
    /**
     * Admin: Withdraw a member's earnings to another address, signed by the member
     * @param memberAddress - the member whose earnings are sent out
     * @param recipientAddress - the address to receive the tokens in mainnet
     * @param signature - from member, produced using signWithdrawAllTo
     * @param sendToMainnet - false = send to sidechain address
     * @returns await on call .wait to actually send the tx
     */
    private getWithdrawAllToSignedTx;
    /**
     * Admin: Withdraw a specific amount member's earnings to another address, signed by the member
     * @param memberAddress - the member whose earnings are sent out
     * @param recipientAddress - the address to receive the tokens in mainnet
     * @param signature - from member, produced using signWithdrawAllTo
     * @returns the sidechain withdraw transaction receipt IF called with sendToMainnet=false,
     *          ELSE the message hash IF called with payForTransport=false and waitUntilTransportIsComplete=false,
     *          ELSE the mainnet AMB signature execution transaction receipt IF we did the transport ourselves,
     *          ELSE null IF transport to mainnet was done by someone else (in which case the receipt is lost)
     */
    withdrawAmountToSigned(memberAddress: EthereumAddress, recipientAddress: EthereumAddress, amountTokenWei: BigNumber | number | string, signature: string, options?: DataUnionWithdrawOptions): Promise<string | ContractReceipt | null>;
    /**
     * Admin: Withdraw a member's earnings to another address, signed by the member
     * @param memberAddress - the member whose earnings are sent out
     * @param recipientAddress - the address to receive the tokens in mainnet
     * @param amount - in "token wei" to withdraw
     * @param signature - from member, produced using signWithdrawAllTo
     * @returns await on call .wait to actually send the tx
     */
    private getWithdrawAmountToSignedTx;
    /**
     * Admin: set admin fee (between 0.0 and 1.0) for the data union
     */
    setAdminFee(newFeeFraction: number, ethersOptions?: EthersOptions): Promise<ContractReceipt>;
    /**
     * Transfer amount to specific member in DataunionSidechain
     * @param memberAddress - target member who gets the tokens added to their earnings in the the Data Union
     * @param amountTokenWei - the amount that want to add to the member
     * @returns receipt once transfer transaction is confirmed
     */
    transferToMemberInContract(memberAddress: EthereumAddress, amountTokenWei: BigNumber | number | string): Promise<ContractReceipt>;
    /**
     * Transfer an amount of earnings to another member in DataunionSidechain
     * @param memberAddress - the other member who gets their tokens out of the Data Union
     * @param amountTokenWei - the amount that want to add to the member
     * @returns receipt once transfer transaction is confirmed
     */
    transferWithinContract(memberAddress: EthereumAddress, amountTokenWei: BigNumber | number | string): Promise<ContractReceipt>;
    private getContracts;
    /**
     * Template for withdraw functions
     * @private
     * @returns the sidechain withdraw transaction receipt IF called with sendToMainnet=false,
     *          ELSE the message hash IF called with payForTransport=false and waitUntilTransportIsComplete=false,
     *          ELSE the mainnet AMB signature execution transaction receipt IF we did the transport ourselves,
     *          ELSE null IF transport to mainnet was done by someone else (in which case the receipt is lost)
     */
    private _executeWithdraw;
    /**
     * @returns null if message was already transported, ELSE the mainnet AMB signature execution transaction receipt
     */
    transportMessage(messageHash: AmbMessageHash, pollingIntervalMs?: number, retryTimeoutMs?: number, ethersOptions?: EthersOptions): Promise<ContractReceipt | null>;
}
