/// <reference types="node" />
import EventEmitter from 'events';
import pMemoize from 'p-memoize';
import mem from 'mem';
import { F } from 'ts-toolbelt';
import LRU from '../../vendor/quick-lru';
import { MaybeAsync } from '../types';
import AggregatedError from './AggregatedError';
import Scaffold from './Scaffold';
export { default as uuid } from './uuid';
export { AggregatedError, Scaffold };
export declare function randomString(length?: number): string;
/**
 * Generates counter-based ids.
 * Basically lodash.uniqueid but per-prefix.
 * Not universally unique.
 * Generally useful for tracking instances.
 *
 * Careful not to use too many prefixes since it needs to hold all prefixes in memory
 * e.g. don't pass new uuid as a prefix
 *
 * counterId('test') => test.0
 * counterId('test') => test.1
 */
export declare const CounterId: (rootPrefix?: string | undefined, { maxPrefixes }?: {
    maxPrefixes?: number | undefined;
}) => {
    (prefix?: string, separator?: string): string;
    /**
     * Clears counts for prefix or all if no prefix supplied.
     *
     * @param {string?} prefix
     */
    clear(...args: [string] | []): void;
};
export declare const counterId: {
    (prefix?: string, separator?: string): string;
    /**
     * Clears counts for prefix or all if no prefix supplied.
     *
     * @param {string?} prefix
     */
    clear(...args: [string] | []): void;
};
export declare function getVersionString(): string;
/**
 * Converts a .once event listener into a promise.
 * Rejects if an 'error' event is received before resolving.
 */
export declare function waitFor(emitter: EventEmitter, event: Parameters<EventEmitter['on']>[0]): Promise<unknown>;
export declare const getEndpointUrl: (baseUrl: string, ...pathParts: string[]) => string;
/**
 * Returns a cached async fn, cached keyed on first argument passed. See documentation for mem/p-memoize.
 * Caches into a LRU cache capped at options.maxSize
 * Won't call asyncFn again until options.maxAge or options.maxSize exceeded, or cachedAsyncFn.clear() is called.
 * Won't cache rejections by default. Override with options.cachePromiseRejection = true.
 *
 * ```js
 * const cachedAsyncFn = CacheAsyncFn(asyncFn, options)
 * await cachedAsyncFn(key)
 * await cachedAsyncFn(key)
 * cachedAsyncFn.clear()
 * ```
 */
export declare type CacheAsyncOptions = Partial<Parameters<typeof pMemoize>[1] & ConstructorParameters<typeof LRU>[0]>;
export declare function CacheAsyncFn(asyncFn: Parameters<typeof pMemoize>[0], { maxSize, maxAge, // 30 minutes
cachePromiseRejection, onEviction, ...opts }?: CacheAsyncOptions): ((...arguments: any[]) => Promise<unknown>) & {
    clear: () => void;
    clearMatching: (matchFn: (key: unknown) => boolean) => void;
};
/**
 * Returns a cached fn, cached keyed on first argument passed. See documentation for mem.
 * Caches into a LRU cache capped at options.maxSize
 * Won't call fn again until options.maxAge or options.maxSize exceeded, or cachedFn.clear() is called.
 *
 * ```js
 * const cachedFn = CacheFn(fn, options)
 * cachedFn(key)
 * cachedFn(key)
 * cachedFn(...args)
 * cachedFn.clear()
 * ```
 */
export declare type CacheOptions = Partial<Parameters<typeof mem>[1] & ConstructorParameters<typeof LRU>[0]>;
export declare function CacheFn(fn: Parameters<typeof mem>[0], { maxSize, maxAge, // 30 minutes
onEviction, ...opts }?: CacheOptions): ((...arguments_: any) => any) & {
    clear: () => void;
    clearMatching: (matchFn: (key: unknown) => boolean) => void;
};
export declare function Defer<T>(executor?: (...args: Parameters<Promise<T>['then']>) => void): Promise<T> & {
    resolve: (reason: any) => unknown;
    reject: (reason: any) => unknown;
    wrap: (fn: F.Function) => (...args: unknown[]) => Promise<unknown>;
    wrapError: (fn: F.Function) => (...args: unknown[]) => Promise<any>;
    handleErrBack: (err?: Error | undefined) => void;
};
export declare function LimitAsyncFnByKey<KeyType>(limit?: number): {
    (id: KeyType, fn: () => Promise<any>): Promise<any>;
    getActiveCount(id: KeyType): number;
    getPendingCount(id: KeyType): number;
    clear(): void;
};
/**
 * Execute functions in parallel, but ensure they resolve in the order they were executed
 */
export declare function pOrderedResolve(fn: F.Function): ((...args: Parameters<typeof fn>) => Promise<unknown>) & {
    clear(): void;
};
/**
 * Returns a function that executes with limited concurrency.
 */
export declare function pLimitFn(fn: F.Function, limit?: number): ((...args: unknown[]) => Promise<any>) & {
    clear(): void;
};
/**
 * Unwrap a Promise type e.g. Awaited<Promise<T>> => T
 * Required as TS doesn't (currently) understand Promise<T> is equivalent to Promise<Promise<T>>
 */
declare type Awaited<T> = T extends PromiseLike<infer U> ? Awaited<U> : T;
/**
 * Only allows one outstanding call.
 * Returns same promise while task is executing.
 */
export declare function pOne<Args extends any[], R>(fn: (...args: Args) => R): (...args: Args) => Promise<Awaited<R>>;
/**
 * Only allows calling `fn` once.
 * Returns same promise while task is executing.
 */
export declare function pOnce<Args extends any[], R>(fn: (...args: Args) => R): (...args: Args) => Promise<Awaited<R>>;
export declare class TimeoutError extends Error {
    timeout: number;
    constructor(msg?: string, timeout?: number);
}
/**
 * Takes a promise and a timeout and an optional message for timeout errors.
 * Returns a promise that rejects when timeout expires, or when promise settles, whichever comes first.
 *
 * Invoke with positional arguments for timeout & message:
 * await pTimeout(promise, timeout, message)
 *
 * or using an options object for timeout, message & rejectOnTimeout:
 *
 * await pTimeout(promise, { timeout, message, rejectOnTimeout })
 *
 * message and rejectOnTimeout are optional.
 */
declare type pTimeoutOpts = {
    timeout?: number;
    message?: string;
    rejectOnTimeout?: boolean;
};
declare type pTimeoutArgs = [timeout?: number, message?: string] | [pTimeoutOpts];
export declare function pTimeout(promise: Promise<unknown>, ...args: pTimeoutArgs): Promise<unknown>;
/**
 * Convert allSettled results into a thrown Aggregate error if necessary.
 */
export declare function allSettledValues(items: Parameters<(typeof Promise)['allSettled']>[0], errorMessage?: string): Promise<unknown[]>;
export declare function sleep(ms?: number): Promise<unknown>;
/**
 * Wait until a condition is true
 * @param condition - wait until this callback function returns true
 * @param timeOutMs - stop waiting after that many milliseconds, -1 for disable
 * @param pollingIntervalMs - check condition between so many milliseconds
 * @param failedMsgFn - append the string return value of this getter function to the error message, if given
 * @return the (last) truthy value returned by the condition function
 */
export declare function until(condition: MaybeAsync<() => boolean>, timeOutMs?: number, pollingIntervalMs?: number, failedMsgFn?: () => string): Promise<boolean>;
