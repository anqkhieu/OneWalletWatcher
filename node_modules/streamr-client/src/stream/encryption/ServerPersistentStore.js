"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const env_paths_1 = __importDefault(require("env-paths"));
const path_1 = require("path");
const fs_1 = require("fs");
const sqlite_1 = require("sqlite");
const sqlite3_1 = __importDefault(require("sqlite3"));
const utils_1 = require("../../utils");
const log_1 = require("../../utils/log");
// eslint-disable-next-line promise/param-names
const wait = (ms) => new Promise((resolveFn) => setTimeout(resolveFn, ms));
class ServerPersistentStore {
    constructor({ clientId, streamId, initialData = {}, rootPath = './', migrationsPath = path_1.join(__dirname, 'migrations') }) {
        this.initCalled = false;
        this.id = utils_1.counterId(this.constructor.name);
        this.debug = log_1.Debug(this.id);
        this.streamId = encodeURIComponent(streamId);
        this.clientId = encodeURIComponent(clientId);
        this.initialData = initialData;
        const paths = env_paths_1.default('streamr-client');
        const dbFilePath = path_1.resolve(paths.data, path_1.join(rootPath, clientId, 'GroupKeys.db'));
        this.dbFilePath = dbFilePath;
        this.migrationsPath = migrationsPath;
        this.init = utils_1.pOnce(this.init.bind(this));
    }
    async exists() {
        if (this.initCalled) {
            // wait for init if in progress
            await this.init();
        }
        try {
            await fs_1.promises.access(this.dbFilePath);
            return true;
        }
        catch (err) {
            if (err.code === 'ENOENT') {
                return false;
            }
            throw err;
        }
    }
    async tryExec(fn, maxRetries = 10, retriesLeft = maxRetries) {
        try {
            return await fn();
        }
        catch (err) {
            if (retriesLeft > 0 && err.code === 'SQLITE_BUSY') {
                this.debug('DB Busy, retrying %d of %d', maxRetries - retriesLeft + 1, maxRetries);
                return this.tryExec(async () => {
                    // wait random time and retry
                    await wait(10 + Math.random() * 500);
                    return fn();
                }, maxRetries, retriesLeft - 1);
            }
            throw err;
        }
    }
    async init() {
        this.initCalled = true;
        try {
            await fs_1.promises.mkdir(path_1.dirname(this.dbFilePath), { recursive: true });
            // open the database
            const store = await sqlite_1.open({
                filename: this.dbFilePath,
                driver: sqlite3_1.default.Database
            });
            await this.tryExec(async () => {
                await store.configure('busyTimeout', 200);
                await store.run('PRAGMA journal_mode = WAL;');
            });
            await this.tryExec(async () => {
                try {
                    await store.migrate({
                        migrationsPath: this.migrationsPath
                    });
                }
                catch (err) {
                    if (err.code.startsWith('SQLITE_')) {
                        // ignore: some other migration is probably running, assume that worked
                        return;
                    }
                    throw err;
                }
            });
            this.store = store;
        }
        catch (err) {
            this.debug('error', err);
            if (!this.error) {
                this.error = err;
            }
        }
        if (this.error) {
            throw this.error;
        }
        await Promise.all(Object.entries(this.initialData).map(async ([key, value]) => {
            return this.setKeyValue(key, value);
        }));
        this.debug('init');
    }
    async get(key) {
        if (!this.initCalled) {
            // can't have if doesn't exist
            if (!(await this.exists())) {
                return undefined;
            }
        }
        await this.init();
        const value = await this.store.get('SELECT groupKey FROM GroupKeys WHERE id = ? AND streamId = ?', key, this.streamId);
        return value === null || value === void 0 ? void 0 : value.groupKey;
    }
    async has(key) {
        if (!this.initCalled) {
            // can't have if doesn't exist
            if (!(await this.exists())) {
                return false;
            }
        }
        await this.init();
        const value = await this.store.get('SELECT COUNT(*) FROM GroupKeys WHERE id = ? AND streamId = ?', key, this.streamId);
        return !!(value && value['COUNT(*)'] != null && value['COUNT(*)'] !== 0);
    }
    async setKeyValue(key, value) {
        // set, but without init so init can insert initialData
        const result = await this.store.run('INSERT INTO GroupKeys VALUES ($id, $groupKey, $streamId) ON CONFLICT DO NOTHING', {
            $id: key,
            $groupKey: value,
            $streamId: this.streamId,
        });
        return !!(result === null || result === void 0 ? void 0 : result.changes);
    }
    async set(key, value) {
        await this.init();
        return this.setKeyValue(key, value);
    }
    async delete(key) {
        if (!this.initCalled) {
            // can't delete if if db doesn't exist
            if (!(await this.exists())) {
                return false;
            }
        }
        await this.init();
        const result = await this.store.run('DELETE FROM GroupKeys WHERE id = ? AND streamId = ?', key, this.streamId);
        return !!(result === null || result === void 0 ? void 0 : result.changes);
    }
    async clear() {
        this.debug('clear');
        if (!this.initCalled) {
            // nothing to clear if doesn't exist
            if (!(await this.exists())) {
                return false;
            }
        }
        await this.init();
        const result = await this.store.run('DELETE FROM GroupKeys WHERE streamId = ?', this.streamId);
        return !!(result === null || result === void 0 ? void 0 : result.changes);
    }
    async size() {
        if (!this.initCalled) {
            // can only have size 0 if doesn't exist
            if (!(await this.exists())) {
                return 0;
            }
        }
        await this.init();
        const size = await this.store.get('SELECT COUNT(*) FROM GroupKeys WHERE streamId = ?;', this.streamId);
        return size && size['COUNT(*)'];
    }
    async close() {
        this.debug('close');
        if (!this.initCalled) {
            // nothing to close if never opened
            return;
        }
        await this.init();
        await this.store.close();
    }
    async destroy() {
        this.debug('destroy');
        if (!this.initCalled) {
            // nothing to destroy if doesn't exist
            if (!(await this.exists())) {
                return;
            }
        }
        await this.clear();
        await this.close();
        this.init = utils_1.pOnce(Object.getPrototypeOf(this).init.bind(this));
    }
    get [Symbol.toStringTag]() {
        return this.constructor.name;
    }
}
exports.default = ServerPersistentStore;
//# sourceMappingURL=ServerPersistentStore.js.map