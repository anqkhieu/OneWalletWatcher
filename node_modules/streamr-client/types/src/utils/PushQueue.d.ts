import { Defer } from './index';
export declare class AbortError extends Error {
    constructor(msg?: string);
}
declare type AnyIterable<T> = Iterable<T> | AsyncIterable<T>;
/**
 * Async Iterable PushQueue
 * On throw/abort any items in buffer will be flushed before iteration throws.
 * Heavily based on (upcoming) events.on API in node:
 * https://github.com/nodejs/node/blob/e36ffb72bebae55091304da51837ca204367dc16/lib/events.js#L707-L826
 *
 * const queue = new PushQueue([item1], {
 *     signal: abortController.signal // optional
 * })
 * queue.push(item2, item3) // supports pushing multiple at once
 * setTimeout(() => {
 *    queue.push(item4) // push asynchronously, iterator will wait
 *    queue.return() // need to explicitly end iteration or it will continue forever
 *    queue.throw(err) // force the queue to throw
 *    abortController.abort() // alternative
 * })
 *
 * try {
 *     for await (const m of queue) {
 *         console.log(m)
 *         break // this calls await queue.return()
 *     }
 * } catch (err) {
 *     // queue threw an error
 * } finally {
 *     // run clean up after iteration success/error
 * }
 *
 */
declare type PushQueueOptions = Partial<{
    signal: AbortSignal;
    onEnd: (err?: Error, ...args: any[]) => void;
    timeout: number;
    autoEnd: boolean;
}>;
export default class PushQueue<T> {
    autoEnd: boolean;
    timeout: number;
    signal: AbortSignal | undefined;
    iterator: AsyncGenerator<T | null | undefined, void, unknown>;
    buffer: T[] | [...T[], null];
    error?: Error;
    nextQueue: (ReturnType<typeof Defer>)[];
    finished: boolean;
    pending: number;
    ended: boolean;
    _onEnd: PushQueueOptions['onEnd'];
    _onEndCalled: boolean;
    _isCancelled: boolean;
    constructor(items?: T[], { signal, onEnd, timeout, autoEnd }?: PushQueueOptions);
    static from<TT>(iterable: AnyIterable<TT>, opts?: {}): PushQueue<TT>;
    static transform<TT, U>(src: AnyIterable<TT>, fn: (value: TT) => U, opts?: {}): PushQueue<U>;
    from(iterable: Iterable<T> | AsyncIterable<T>, { end }?: {
        end?: boolean | undefined;
    }): Promise<void>;
    onEnd(err?: Error, ...args: any[]): void | Promise<void>;
    /**
     * signals no more data should be buffered
     */
    end(v?: T | null): void;
    onAbort(): Promise<void>;
    next(...args: [] | [unknown]): Promise<IteratorResult<T | null | undefined, void>>;
    isWritable(): boolean;
    isReadable(): boolean;
    return(): Promise<void>;
    throw(err: Error): Promise<void>;
    get length(): number;
    _cleanup(): Promise<void>;
    push(...values: (T | null)[]): void;
    iterate(): AsyncGenerator<T | null | undefined, void, unknown>;
    pipe(next: PushQueue<unknown>, opts: Parameters<PushQueue<unknown>['from']>[1]): Promise<void>;
    cancel(error?: Error): Promise<void>;
    isCancelled(): boolean;
    [Symbol.asyncIterator](): AsyncGenerator<T | null | undefined, void, unknown>;
}
export {};
