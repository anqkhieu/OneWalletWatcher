import { StreamMessage } from 'streamr-client-protocol';
import { LimitAsyncFnByKey } from '../utils';
import { GroupKey } from '../stream';
import { StreamrClient } from '../StreamrClient';
import MessageChainer from './MessageChainer';
import { StreamIDish } from './utils';
export default class StreamMessageCreator {
    computeStreamPartition: {
        (partitionCount: number, partitionKey: string | number): any;
        clear: () => void;
    };
    encrypt: ((streamMessage: StreamMessage, stream: import("../stream").Stream) => Promise<void>) & {
        setNextGroupKey(streamId: string, groupKey: GroupKey): Promise<void>;
        rotateGroupKey(streamId: string): Promise<void>;
        rekey(streamId: string): Promise<void>;
        start(): Promise<void>;
        stop(): Promise<void>;
    };
    queue: ReturnType<typeof LimitAsyncFnByKey>;
    getMsgChainer: typeof MessageChainer & {
        clear: () => void;
    };
    signStreamMessage: ((streamMessage: StreamMessage) => StreamMessage) | (((streamMessage: StreamMessage, signatureType?: import("streamr-client-protocol/dist/src/protocol/message_layer/StreamMessage").SignatureType) => Promise<StreamMessage & {
        signature: any;
    }>) & {
        signData: (((...args: unknown[]) => Promise<any>) & {
            clear(): void;
        }) | ((d: string) => Promise<string>);
    });
    client: StreamrClient;
    constructor(client: StreamrClient);
    create(streamObjectOrId: StreamIDish, { content, timestamp, partitionKey, msgChainId, ...opts }: {
        content: any;
        timestamp: string | number | Date;
        partitionKey?: string | number;
        msgChainId?: string;
    }): Promise<StreamMessage>;
    setNextGroupKey(maybeStreamId: string, newKey: GroupKey): Promise<void>;
    rotateGroupKey(maybeStreamId: string): Promise<void>;
    rekey(maybeStreamId: string): Promise<void>;
    startKeyExchange(): Promise<void>;
    stop(): Promise<void>;
}
