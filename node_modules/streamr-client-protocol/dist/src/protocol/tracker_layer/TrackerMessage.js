"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TrackerMessageType = void 0;
const UnsupportedVersionError_1 = __importDefault(require("../../errors/UnsupportedVersionError"));
const UnsupportedTypeError_1 = __importDefault(require("../../errors/UnsupportedTypeError"));
const validations_1 = require("../../utils/validations");
// TODO use ControlMessageType instead of number when we have real enums
const serializerByVersionAndType = {};
const LATEST_VERSION = 2;
var TrackerMessageType;
(function (TrackerMessageType) {
    TrackerMessageType[TrackerMessageType["StatusMessage"] = 1] = "StatusMessage";
    TrackerMessageType[TrackerMessageType["InstructionMessage"] = 2] = "InstructionMessage";
    TrackerMessageType[TrackerMessageType["RelayMessage"] = 5] = "RelayMessage";
    TrackerMessageType[TrackerMessageType["ErrorMessage"] = 6] = "ErrorMessage";
})(TrackerMessageType = exports.TrackerMessageType || (exports.TrackerMessageType = {}));
class TrackerMessage {
    constructor(version = LATEST_VERSION, type, requestId) {
        if (new.target === TrackerMessage) {
            throw new TypeError('TrackerMessage is abstract.');
        }
        (0, validations_1.validateIsInteger)('version', version);
        (0, validations_1.validateIsInteger)('type', type);
        (0, validations_1.validateIsString)('requestId', requestId);
        this.version = version;
        this.type = type;
        this.requestId = requestId;
    }
    static registerSerializer(version, type, serializer) {
        // Check the serializer interface
        if (!serializer.fromArray) {
            throw new Error(`Serializer ${JSON.stringify(serializer)} doesn't implement a method fromArray!`);
        }
        if (!serializer.toArray) {
            throw new Error(`Serializer ${JSON.stringify(serializer)} doesn't implement a method toArray!`);
        }
        if (serializerByVersionAndType[version] === undefined) {
            serializerByVersionAndType[version] = {};
        }
        if (serializerByVersionAndType[version][type] !== undefined) {
            throw new Error(`Serializer for version ${version} and type ${type} is already registered: ${JSON.stringify(serializerByVersionAndType[version][type])}`);
        }
        serializerByVersionAndType[version][type] = serializer;
    }
    static unregisterSerializer(version, type) {
        delete serializerByVersionAndType[version][type];
    }
    static getSerializer(version, type) {
        const serializersByType = serializerByVersionAndType[version];
        if (!serializersByType) {
            throw new UnsupportedVersionError_1.default(version, `Supported versions: [${TrackerMessage.getSupportedVersions()}]`);
        }
        const clazz = serializersByType[type];
        if (!clazz) {
            throw new UnsupportedTypeError_1.default(type, `Supported types: [${Object.keys(serializersByType)}]`);
        }
        return clazz;
    }
    static getSupportedVersions() {
        return Object.keys(serializerByVersionAndType).map((key) => parseInt(key, 10));
    }
    serialize(version = this.version, ...typeSpecificSerializeArgs) {
        return JSON.stringify(TrackerMessage.getSerializer(version, this.type).toArray(this, ...typeSpecificSerializeArgs));
    }
    /**
     * Takes a serialized representation (array or string) of a message, and returns a ControlMessage instance.
     */
    static deserialize(msg, ...typeSpecificDeserializeArgs) {
        const messageArray = (typeof msg === 'string' ? JSON.parse(msg) : msg);
        /* eslint-disable prefer-destructuring */
        const messageVersion = messageArray[0];
        const messageType = messageArray[1];
        /* eslint-enable prefer-destructuring */
        const C = TrackerMessage.getSerializer(messageVersion, messageType);
        return C.fromArray(messageArray, ...typeSpecificDeserializeArgs);
    }
}
exports.default = TrackerMessage;
TrackerMessage.LATEST_VERSION = LATEST_VERSION;
TrackerMessage.TYPES = TrackerMessageType; // TODO can we remove this and use the enum object directly?
//# sourceMappingURL=TrackerMessage.js.map