"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.FailedToPublishError = void 0;
const streamr_client_protocol_1 = require("streamr-client-protocol");
const utils_1 = require("../utils");
const log_1 = require("../utils/log");
const utils_2 = require("../stream/utils");
const MessageCreator_1 = __importDefault(require("./MessageCreator"));
const utils_3 = require("./utils");
class FailedToPublishError extends Error {
    constructor(streamId, msg, reason) {
        super(`Failed to publish to stream ${streamId} due to: ${reason && reason.stack ? reason.stack : reason}. Message was: ${log_1.inspect(msg)}`);
        this.streamId = streamId;
        this.msg = msg;
        this.reason = reason;
        if (Error.captureStackTrace) {
            Error.captureStackTrace(this, this.constructor);
        }
    }
    [Symbol.for('nodejs.util.inspect.custom')](depth, options) {
        return log_1.inspect(this, {
            ...options,
            customInspect: false,
            depth,
        });
    }
}
exports.FailedToPublishError = FailedToPublishError;
/**
 * Add handle to keep connection open while publishing.
 * Refreshes handle timeout on each call.
 * Only remove publish handle after inactivity of options.publishAutoDisconnectDelay ms.
 */
class Publisher {
    constructor(client) {
        this.publishHandle = Symbol('publish');
        this.client = client;
        this.debug = client.debug.extend('Publisher');
        this.sendQueue = utils_1.LimitAsyncFnByKey(1);
        this.clearRemovePublishHandleTimeout = this.clearRemovePublishHandleTimeout.bind(this);
        this.streamMessageCreator = new MessageCreator_1.default(client);
        this.onErrorEmit = client.getErrorEmitter({
            debug: this.debug
        });
    }
    async listenForErrors(request) {
        // listen for errors for this request for 3s
        await utils_2.waitForRequestResponse(this.client, request, {
            timeout: 3000,
            rejectOnTimeout: false,
        });
    }
    async sendMessage(streamMessage, sessionToken) {
        const { client } = this;
        const requestId = utils_1.uuid('pub');
        const request = new streamr_client_protocol_1.ControlLayer.PublishRequest({
            streamMessage,
            requestId,
            sessionToken: sessionToken || null,
        });
        this.listenForErrors(request).catch(this.onErrorEmit); // unchained async
        // send calls should probably also fire in-order otherwise new realtime streams
        // can miss messages that are sent late
        await client.send(request);
        return request;
    }
    async publishMessage(streamObjectOrId, { content, timestamp = new Date(), partitionKey }) {
        if (this.client.session.isUnauthenticated()) {
            throw new Error('Need to be authenticated to publish.');
        }
        const streamId = utils_3.getStreamId(streamObjectOrId);
        // get session, connection + generate stream message in parallel
        // NOTE: createStreamMessage *must* be executed in publish() call order or sequencing will be broken.
        // i.e. don't do anything async before calling createStreamMessage
        const asyncDepsTask = Promise.all([
            // no async before running createStreamMessage
            this.streamMessageCreator.create(streamObjectOrId, {
                content,
                timestamp,
                partitionKey,
            }),
            this.setupPublishHandle(), // autoconnect client if necessary
        ]);
        asyncDepsTask.catch(() => {
            // prevent unhandledrejection, should wait for queue
            // will still reject in queue
        });
        // no async before running sendQueue
        return this.sendQueue(streamId, async () => {
            const [streamMessage] = await asyncDepsTask;
            const sessionToken = await this.client.session.getSessionToken();
            try {
                return await this.sendMessage(streamMessage, sessionToken);
            }
            finally {
                this.refreshAutoDisconnectTimeout();
            }
        });
    }
    /**
     * Create publish handle to keep connection open while publishing.
     */
    async setupPublishHandle() {
        // remove any existing
        this.clearRemovePublishHandleTimeout();
        this.client.connection.once('done', this.clearRemovePublishHandleTimeout);
        await this.client.connection.addHandle(this.publishHandle);
    }
    clearRemovePublishHandleTimeout() {
        const timeout = this.publishHandleTimeout;
        if (timeout) {
            clearTimeout(timeout);
            this.publishHandleTimeout = undefined;
        }
        this.client.connection.off('done', this.clearRemovePublishHandleTimeout);
    }
    /**
     * Reset publish handle timeout, or start new
     */
    refreshAutoDisconnectTimeout() {
        const { client } = this;
        this.clearRemovePublishHandleTimeout();
        if (!client.connection.connectionHandles.has(this.publishHandle)) {
            // do nothing if already removed
            return;
        }
        const { publishAutoDisconnectDelay = 5000 } = client.options;
        this.publishHandleTimeout = setTimeout(async () => {
            this.clearRemovePublishHandleTimeout();
            try {
                await client.connection.removeHandle(this.publishHandle);
            }
            catch (err) {
                client.emit('error', err);
            }
        }, publishAutoDisconnectDelay || 0);
    }
    async publish(streamObjectOrId, content, timestamp, partitionKey) {
        // wrap publish in error emitter
        try {
            return await this.publishMessage(streamObjectOrId, {
                content,
                timestamp,
                partitionKey,
            });
        }
        catch (err) {
            const streamId = utils_3.getStreamId(streamObjectOrId);
            const error = new FailedToPublishError(streamId, content, err);
            this.onErrorEmit(error);
            throw error;
        }
    }
    async startKeyExchange() {
        return this.streamMessageCreator.startKeyExchange();
    }
    async stop() {
        this.sendQueue.clear();
        this.clearRemovePublishHandleTimeout();
        await this.streamMessageCreator.stop();
        await this.client.connection.removeHandle(this.publishHandle);
    }
    rotateGroupKey(streamId) {
        return this.streamMessageCreator.rotateGroupKey(streamId);
    }
    setNextGroupKey(streamId, newKey) {
        return this.streamMessageCreator.setNextGroupKey(streamId, newKey);
    }
    rekey(streamId) {
        return this.streamMessageCreator.rekey(streamId);
    }
}
exports.default = Publisher;
//# sourceMappingURL=index.js.map