"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.EncryptionType = exports.SignatureType = exports.ContentType = exports.StreamMessageType = void 0;
const InvalidJsonError_1 = __importDefault(require("../../errors/InvalidJsonError"));
const StreamMessageError_1 = __importDefault(require("../../errors/StreamMessageError"));
const ValidationError_1 = __importDefault(require("../../errors/ValidationError"));
const UnsupportedVersionError_1 = __importDefault(require("../../errors/UnsupportedVersionError"));
const validations_1 = require("../../utils/validations");
const SPID_1 = require("../../utils/SPID");
const MessageRef_1 = __importDefault(require("./MessageRef"));
const MessageID_1 = __importDefault(require("./MessageID"));
const EncryptedGroupKey_1 = __importDefault(require("./EncryptedGroupKey"));
const serializerByVersion = {};
const BYE_KEY = '_bye';
const LATEST_VERSION = 32;
var StreamMessageType;
(function (StreamMessageType) {
    StreamMessageType[StreamMessageType["MESSAGE"] = 27] = "MESSAGE";
    StreamMessageType[StreamMessageType["GROUP_KEY_REQUEST"] = 28] = "GROUP_KEY_REQUEST";
    StreamMessageType[StreamMessageType["GROUP_KEY_RESPONSE"] = 29] = "GROUP_KEY_RESPONSE";
    StreamMessageType[StreamMessageType["GROUP_KEY_ANNOUNCE"] = 30] = "GROUP_KEY_ANNOUNCE";
    StreamMessageType[StreamMessageType["GROUP_KEY_ERROR_RESPONSE"] = 31] = "GROUP_KEY_ERROR_RESPONSE";
})(StreamMessageType = exports.StreamMessageType || (exports.StreamMessageType = {}));
var ContentType;
(function (ContentType) {
    ContentType[ContentType["JSON"] = 0] = "JSON";
})(ContentType = exports.ContentType || (exports.ContentType = {}));
var SignatureType;
(function (SignatureType) {
    SignatureType[SignatureType["NONE"] = 0] = "NONE";
    SignatureType[SignatureType["ETH_LEGACY"] = 1] = "ETH_LEGACY";
    SignatureType[SignatureType["ETH"] = 2] = "ETH";
})(SignatureType = exports.SignatureType || (exports.SignatureType = {}));
var EncryptionType;
(function (EncryptionType) {
    EncryptionType[EncryptionType["NONE"] = 0] = "NONE";
    EncryptionType[EncryptionType["RSA"] = 1] = "RSA";
    EncryptionType[EncryptionType["AES"] = 2] = "AES";
})(EncryptionType = exports.EncryptionType || (exports.EncryptionType = {}));
class StreamMessage {
    constructor({ messageId, prevMsgRef = null, content, messageType = StreamMessage.MESSAGE_TYPES.MESSAGE, contentType = StreamMessage.CONTENT_TYPES.JSON, encryptionType = StreamMessage.ENCRYPTION_TYPES.NONE, groupKeyId = null, newGroupKey = null, signatureType = StreamMessage.SIGNATURE_TYPES.NONE, signature = null, }) {
        (0, validations_1.validateIsType)('messageId', messageId, 'MessageID', MessageID_1.default);
        this.messageId = messageId;
        (0, validations_1.validateIsType)('prevMsgRef', prevMsgRef, 'MessageRef', MessageRef_1.default, true);
        this.prevMsgRef = prevMsgRef;
        StreamMessage.validateMessageType(messageType);
        this.messageType = messageType;
        StreamMessage.validateContentType(contentType);
        this.contentType = contentType;
        StreamMessage.validateEncryptionType(encryptionType);
        this.encryptionType = encryptionType;
        (0, validations_1.validateIsString)('groupKeyId', groupKeyId, true);
        this.groupKeyId = groupKeyId;
        (0, validations_1.validateIsType)('newGroupKey', newGroupKey, 'EncryptedGroupKey', EncryptedGroupKey_1.default, true);
        this.newGroupKey = newGroupKey;
        StreamMessage.validateSignatureType(signatureType);
        this.signatureType = signatureType;
        (0, validations_1.validateIsString)('signature', signature, true);
        this.signature = signature;
        if (typeof content === 'string') {
            // this.parsedContent gets written lazily
            this.serializedContent = content;
        }
        else {
            this.parsedContent = content;
            this.serializedContent = JSON.stringify(content);
        }
        (0, validations_1.validateIsNotEmptyString)('content', this.serializedContent);
        StreamMessage.validateSequence(this);
        this.spid = SPID_1.SPID.from(this.messageId);
    }
    /**
     * Create a new StreamMessage identical to the passed-in streamMessage.
     */
    clone() {
        const content = this.encryptionType === StreamMessage.ENCRYPTION_TYPES.NONE
            ? this.getParsedContent()
            : this.getSerializedContent();
        return new StreamMessage({
            messageId: this.messageId.clone(),
            prevMsgRef: this.prevMsgRef ? this.prevMsgRef.clone() : null,
            content,
            messageType: this.messageType,
            contentType: this.contentType,
            encryptionType: this.encryptionType,
            groupKeyId: this.groupKeyId,
            newGroupKey: this.newGroupKey,
            signatureType: this.signatureType,
            signature: this.signature,
        });
    }
    getStreamId() {
        return this.messageId.streamId;
    }
    getStreamPartition() {
        return this.messageId.streamPartition;
    }
    getSPID() {
        return this.spid;
    }
    getTimestamp() {
        return this.messageId.timestamp;
    }
    getSequenceNumber() {
        return this.messageId.sequenceNumber;
    }
    getPublisherId() {
        return this.messageId.publisherId;
    }
    getMsgChainId() {
        return this.messageId.msgChainId;
    }
    getMessageRef() {
        return new MessageRef_1.default(this.getTimestamp(), this.getSequenceNumber());
    }
    getPreviousMessageRef() {
        return this.prevMsgRef;
    }
    getMessageID() {
        return this.messageId;
    }
    getSerializedContent() {
        return this.serializedContent;
    }
    /**
     * Lazily parses the content to JSON
     */
    getParsedContent() {
        if (this.parsedContent == null) {
            // Don't try to parse encrypted messages
            if (this.messageType === StreamMessage.MESSAGE_TYPES.MESSAGE && this.encryptionType !== StreamMessage.ENCRYPTION_TYPES.NONE) {
                // @ts-expect-error need type narrowing for encrypted vs unencrypted
                return this.serializedContent;
            }
            if (this.contentType === StreamMessage.CONTENT_TYPES.JSON) {
                try {
                    this.parsedContent = JSON.parse(this.serializedContent);
                }
                catch (err) {
                    throw new InvalidJsonError_1.default(this.getStreamId(), err, this);
                }
            }
            else {
                throw new StreamMessageError_1.default(`Unsupported contentType for getParsedContent: ${this.contentType}`, this);
            }
        }
        // should be expected type by here
        return this.parsedContent;
    }
    getContent(parsedContent = true) {
        if (parsedContent) {
            return this.getParsedContent();
        }
        return this.getSerializedContent();
    }
    getNewGroupKey() {
        return this.newGroupKey;
    }
    isByeMessage() {
        return !!(this.getParsedContent()[BYE_KEY]);
    }
    /**
     * Gets appropriate payload to sign for this signature type.
     * Optionally sets new signature type at same time, which allows typesafe
     * signing without messages needing to be in a partially signed state.
     * e.g.
     * ```
     * const signedMessage: StreamMessageSigned = Object.assign(unsigedMessage, {
     *     signature: unsigedMessage.getPayloadToSign(SignatureType.ETH),
     * })
     * ```
     */
    getPayloadToSign(newSignatureType) {
        if (newSignatureType != null) {
            StreamMessage.validateSignatureType(newSignatureType);
            this.signatureType = newSignatureType;
        }
        const { signatureType } = this;
        if (signatureType === StreamMessage.SIGNATURE_TYPES.ETH) {
            // Nullable fields
            const prev = (this.prevMsgRef ? `${this.prevMsgRef.timestamp}${this.prevMsgRef.sequenceNumber}` : '');
            const newGroupKey = (this.newGroupKey ? this.newGroupKey.serialize() : '');
            return `${this.getStreamId()}${this.getStreamPartition()}${this.getTimestamp()}${this.messageId.sequenceNumber}`
                + `${this.getPublisherId().toLowerCase()}${this.messageId.msgChainId}${prev}${this.getSerializedContent()}${newGroupKey}`;
        }
        if (signatureType === StreamMessage.SIGNATURE_TYPES.ETH_LEGACY) {
            // verification of messages signed by old clients
            return `${this.getStreamId()}${this.getTimestamp()}${this.getPublisherId().toLowerCase()}${this.getSerializedContent()}`;
        }
        throw new ValidationError_1.default(`Unrecognized signature type: ${signatureType}`);
    }
    static registerSerializer(version, serializer) {
        // Check the serializer interface
        if (!serializer.fromArray) {
            throw new Error(`Serializer ${JSON.stringify(serializer)} doesn't implement a method fromArray!`);
        }
        if (!serializer.toArray) {
            throw new Error(`Serializer ${JSON.stringify(serializer)} doesn't implement a method toArray!`);
        }
        if (serializerByVersion[version] !== undefined) {
            throw new Error(`Serializer for version ${version} is already registered: ${JSON.stringify(serializerByVersion[version])}`);
        }
        serializerByVersion[version] = serializer;
    }
    static unregisterSerializer(version) {
        delete serializerByVersion[version];
    }
    static getSerializer(version) {
        const clazz = serializerByVersion[version];
        if (!clazz) {
            throw new UnsupportedVersionError_1.default(version, `Supported versions: [${StreamMessage.getSupportedVersions()}]`);
        }
        return clazz;
    }
    static getSupportedVersions() {
        return Object.keys(serializerByVersion).map((key) => parseInt(key, 10));
    }
    serialize(version = LATEST_VERSION) {
        const serializer = StreamMessage.getSerializer(version);
        return JSON.stringify(serializer.toArray(this));
    }
    /**
     * Takes a serialized representation (array or string) of a message, and returns a StreamMessage instance.
     */
    static deserialize(msg) {
        const messageArray = (typeof msg === 'string' ? JSON.parse(msg) : msg);
        /* eslint-disable prefer-destructuring */
        const messageVersion = messageArray[0];
        /* eslint-enable prefer-destructuring */
        const C = StreamMessage.getSerializer(messageVersion);
        return C.fromArray(messageArray);
    }
    static validateMessageType(messageType) {
        if (!StreamMessage.VALID_MESSAGE_TYPES.has(messageType)) {
            throw new ValidationError_1.default(`Unsupported message type: ${messageType}`);
        }
    }
    static validateContentType(contentType) {
        if (!StreamMessage.VALID_CONTENT_TYPES.has(contentType)) {
            throw new ValidationError_1.default(`Unsupported content type: ${contentType}`);
        }
    }
    static validateEncryptionType(encryptionType) {
        if (!StreamMessage.VALID_ENCRYPTIONS.has(encryptionType)) {
            throw new ValidationError_1.default(`Unsupported encryption type: ${encryptionType}`);
        }
    }
    static validateSignatureType(signatureType) {
        if (!StreamMessage.VALID_SIGNATURE_TYPES.has(signatureType)) {
            throw new ValidationError_1.default(`Unsupported signature type: ${signatureType}`);
        }
    }
    static versionSupportsEncryption(streamMessageVersion) {
        return streamMessageVersion >= 31;
    }
    static validateSequence({ messageId, prevMsgRef }) {
        if (!prevMsgRef) {
            return;
        }
        const comparison = messageId.toMessageRef().compareTo(prevMsgRef);
        // cannot have same timestamp + sequence
        if (comparison === 0) {
            throw new ValidationError_1.default(`prevMessageRef cannot be identical to current. Current: ${messageId.toMessageRef().toArray()} Previous: ${prevMsgRef.toArray()}`);
        }
        // previous cannot be newer
        if (comparison < 0) {
            throw new ValidationError_1.default(`prevMessageRef must come before current. Current: ${messageId.toMessageRef().toArray()} Previous: ${prevMsgRef.toArray()}`);
        }
    }
    static isUnsigned(msg) {
        return !this.isSigned(msg);
    }
    static isSigned(msg) {
        return !!(msg && msg.signature && msg.signatureType !== SignatureType.NONE);
    }
    static isEncrypted(msg) {
        return !!(msg && msg.encryptionType !== EncryptionType.NONE);
    }
    static isUnencrypted(msg) {
        return !this.isEncrypted(msg);
    }
    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
    static isStreamMessageContainer(content) {
        return !!(content && typeof content === 'object' && 'toStreamMessage' in content && typeof content.toStreamMessage === 'function');
    }
    toObject() {
        return {
            streamId: this.getStreamId(),
            streamPartition: this.getStreamPartition(),
            timestamp: this.getTimestamp(),
            sequenceNumber: this.getSequenceNumber(),
            publisherId: this.getPublisherId(),
            msgChainId: this.getMsgChainId(),
            messageType: this.messageType,
            contentType: this.contentType,
            encryptionType: this.encryptionType,
            groupKeyId: this.groupKeyId,
            content: (this.encryptionType === StreamMessage.ENCRYPTION_TYPES.NONE ? this.getParsedContent() : this.getSerializedContent()),
            signatureType: this.signatureType,
            signature: this.signature,
        };
    }
}
exports.default = StreamMessage;
StreamMessage.LATEST_VERSION = LATEST_VERSION;
// TODO can we remove these static field and use the enum object directly?
StreamMessage.MESSAGE_TYPES = StreamMessageType;
StreamMessage.VALID_MESSAGE_TYPES = new Set(Object.values(StreamMessage.MESSAGE_TYPES));
StreamMessage.CONTENT_TYPES = ContentType;
StreamMessage.VALID_CONTENT_TYPES = new Set(Object.values(StreamMessage.CONTENT_TYPES));
StreamMessage.SIGNATURE_TYPES = SignatureType;
StreamMessage.VALID_SIGNATURE_TYPES = new Set(Object.values(StreamMessage.SIGNATURE_TYPES));
StreamMessage.ENCRYPTION_TYPES = EncryptionType;
StreamMessage.VALID_ENCRYPTIONS = new Set(Object.values(StreamMessage.ENCRYPTION_TYPES));
//# sourceMappingURL=StreamMessage.js.map