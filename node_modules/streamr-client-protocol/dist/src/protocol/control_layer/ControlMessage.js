"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ControlMessageType = exports.PLACEHOLDER_REQUEST_ID_PROTOCOL_V1 = void 0;
const UnsupportedVersionError_1 = __importDefault(require("../../errors/UnsupportedVersionError"));
const UnsupportedTypeError_1 = __importDefault(require("../../errors/UnsupportedTypeError"));
const validations_1 = require("../../utils/validations");
// TODO use ControlMessageType instead of number when we have real enums
const serializerByVersionAndType = {};
const LATEST_VERSION = 2;
exports.PLACEHOLDER_REQUEST_ID_PROTOCOL_V1 = 'PLACEHOLDER_REQUEST_ID_PROTOCOL_V1';
var ControlMessageType;
(function (ControlMessageType) {
    ControlMessageType[ControlMessageType["BroadcastMessage"] = 0] = "BroadcastMessage";
    ControlMessageType[ControlMessageType["UnicastMessage"] = 1] = "UnicastMessage";
    ControlMessageType[ControlMessageType["SubscribeResponse"] = 2] = "SubscribeResponse";
    ControlMessageType[ControlMessageType["UnsubscribeResponse"] = 3] = "UnsubscribeResponse";
    ControlMessageType[ControlMessageType["ResendResponseResending"] = 4] = "ResendResponseResending";
    ControlMessageType[ControlMessageType["ResendResponseResent"] = 5] = "ResendResponseResent";
    ControlMessageType[ControlMessageType["ResendResponseNoResend"] = 6] = "ResendResponseNoResend";
    ControlMessageType[ControlMessageType["ErrorResponse"] = 7] = "ErrorResponse";
    ControlMessageType[ControlMessageType["PublishRequest"] = 8] = "PublishRequest";
    ControlMessageType[ControlMessageType["SubscribeRequest"] = 9] = "SubscribeRequest";
    ControlMessageType[ControlMessageType["UnsubscribeRequest"] = 10] = "UnsubscribeRequest";
    ControlMessageType[ControlMessageType["ResendLastRequest"] = 11] = "ResendLastRequest";
    ControlMessageType[ControlMessageType["ResendFromRequest"] = 12] = "ResendFromRequest";
    ControlMessageType[ControlMessageType["ResendRangeRequest"] = 13] = "ResendRangeRequest";
})(ControlMessageType = exports.ControlMessageType || (exports.ControlMessageType = {}));
class ControlMessage {
    constructor(version = LATEST_VERSION, type, requestId) {
        if (new.target === ControlMessage) {
            throw new TypeError('ControlMessage is abstract.');
        }
        (0, validations_1.validateIsInteger)('version', version);
        this.version = version;
        (0, validations_1.validateIsInteger)('type', type);
        this.type = type;
        // Since V2 - allow null in older versions
        (0, validations_1.validateIsString)('requestId', requestId, version < 2);
        this.requestId = requestId;
    }
    static registerSerializer(version, type, serializer) {
        // Check the serializer interface
        if (!serializer.fromArray) {
            throw new Error(`Serializer ${JSON.stringify(serializer)} doesn't implement a method fromArray!`);
        }
        if (!serializer.toArray) {
            throw new Error(`Serializer ${JSON.stringify(serializer)} doesn't implement a method toArray!`);
        }
        if (serializerByVersionAndType[version] === undefined) {
            serializerByVersionAndType[version] = {};
        }
        if (serializerByVersionAndType[version][type] !== undefined) {
            throw new Error(`Serializer for version ${version} and type ${type} is already registered: ${JSON.stringify(serializerByVersionAndType[version][type])}`);
        }
        serializerByVersionAndType[version][type] = serializer;
    }
    static unregisterSerializer(version, type) {
        delete serializerByVersionAndType[version][type];
    }
    static getSerializer(version, type) {
        const serializersByType = serializerByVersionAndType[version];
        if (!serializersByType) {
            throw new UnsupportedVersionError_1.default(version, `Supported versions: [${ControlMessage.getSupportedVersions()}]`);
        }
        const clazz = serializersByType[type];
        if (!clazz) {
            throw new UnsupportedTypeError_1.default(type, `Supported types: [${Object.keys(serializersByType)}]`);
        }
        return clazz;
    }
    static getSupportedVersions() {
        return Object.keys(serializerByVersionAndType).map((key) => parseInt(key, 10));
    }
    serialize(version = this.version, ...typeSpecificSerializeArgs) {
        return JSON.stringify(ControlMessage.getSerializer(version, this.type).toArray(this, ...typeSpecificSerializeArgs));
    }
    /**
     * Takes a serialized representation (array or string) of a message, and returns a ControlMessage instance.
     */
    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
    static deserialize(msg, ...typeSpecificDeserializeArgs) {
        const messageArray = (typeof msg === 'string' ? JSON.parse(msg) : msg);
        /* eslint-disable prefer-destructuring */
        const messageVersion = messageArray[0];
        const messageType = messageArray[1];
        /* eslint-enable prefer-destructuring */
        const C = ControlMessage.getSerializer(messageVersion, messageType);
        return C.fromArray(messageArray, ...typeSpecificDeserializeArgs);
    }
}
exports.default = ControlMessage;
ControlMessage.LATEST_VERSION = LATEST_VERSION;
ControlMessage.TYPES = ControlMessageType; // TODO can we remove this and use the enum object directly?
//# sourceMappingURL=ControlMessage.js.map