"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.GroupKey = exports.UnableToDecryptError = exports.StreamMessageProcessingError = void 0;
const crypto_1 = __importDefault(require("crypto"));
const util_1 = require("util");
// this is shimmed out for actual browser build allows us to run tests in node against browser API
const node_webcrypto_ossl_1 = require("node-webcrypto-ossl");
const bytes_1 = require("@ethersproject/bytes");
const streamr_client_protocol_1 = require("streamr-client-protocol");
const utils_1 = require("../../utils");
const log_1 = require("../../utils/log");
const { StreamMessage, EncryptedGroupKey } = streamr_client_protocol_1.MessageLayer;
class StreamMessageProcessingError extends Error {
    constructor(message = '', streamMessage) {
        super(`Could not process. ${message} ${log_1.inspect(streamMessage)}`);
        this.streamMessage = streamMessage;
        if (Error.captureStackTrace) {
            Error.captureStackTrace(this, this.constructor);
        }
    }
}
exports.StreamMessageProcessingError = StreamMessageProcessingError;
class UnableToDecryptError extends StreamMessageProcessingError {
    constructor(message = '', streamMessage) {
        super(`Unable to decrypt. ${message} ${log_1.inspect(streamMessage)}`, streamMessage);
        if (Error.captureStackTrace) {
            Error.captureStackTrace(this, this.constructor);
        }
    }
}
exports.UnableToDecryptError = UnableToDecryptError;
class InvalidGroupKeyError extends Error {
    constructor(message, groupKey) {
        super(message);
        this.groupKey = groupKey;
        if (Error.captureStackTrace) {
            Error.captureStackTrace(this, this.constructor);
        }
    }
}
function GroupKeyObjectFromProps(data) {
    if ('groupKeyId' in data) {
        return {
            id: data.groupKeyId,
            hex: data.groupKeyHex,
            data: data.groupKeyData,
        };
    }
    return data;
}
// eslint-disable-next-line no-redeclare
class GroupKey {
    constructor(groupKeyId, groupKeyBufferOrHexString) {
        this.id = groupKeyId;
        if (!groupKeyId) {
            throw new InvalidGroupKeyError(`groupKeyId must not be falsey ${log_1.inspect(groupKeyId)}`);
        }
        if (!groupKeyBufferOrHexString) {
            throw new InvalidGroupKeyError(`groupKeyBufferOrHexString must not be falsey ${log_1.inspect(groupKeyBufferOrHexString)}`);
        }
        if (typeof groupKeyBufferOrHexString === 'string') {
            this.hex = groupKeyBufferOrHexString;
            this.data = Buffer.from(this.hex, 'hex');
        }
        else {
            this.data = groupKeyBufferOrHexString;
            this.hex = Buffer.from(this.data).toString('hex');
        }
        // eslint-disable-next-line no-extra-semi
        ;
        this.constructor.validate(this);
    }
    static validate(maybeGroupKey) {
        if (!maybeGroupKey) {
            throw new InvalidGroupKeyError(`value must be a ${this.name}: ${log_1.inspect(maybeGroupKey)}`, maybeGroupKey);
        }
        if (!(maybeGroupKey instanceof this)) {
            throw new InvalidGroupKeyError(`value must be a ${this.name}: ${log_1.inspect(maybeGroupKey)}`, maybeGroupKey);
        }
        if (!maybeGroupKey.id || typeof maybeGroupKey.id !== 'string') {
            throw new InvalidGroupKeyError(`${this.name} id must be a string: ${log_1.inspect(maybeGroupKey)}`, maybeGroupKey);
        }
        if (maybeGroupKey.id.includes('---BEGIN')) {
            throw new InvalidGroupKeyError(`${this.name} public/private key is not a valid group key id: ${log_1.inspect(maybeGroupKey)}`, maybeGroupKey);
        }
        if (!maybeGroupKey.data || !Buffer.isBuffer(maybeGroupKey.data)) {
            throw new InvalidGroupKeyError(`${this.name} data must be a Buffer: ${log_1.inspect(maybeGroupKey)}`, maybeGroupKey);
        }
        if (!maybeGroupKey.hex || typeof maybeGroupKey.hex !== 'string') {
            throw new InvalidGroupKeyError(`${this.name} hex must be a string: ${log_1.inspect(maybeGroupKey)}`, maybeGroupKey);
        }
        if (maybeGroupKey.data.length !== 32) {
            throw new InvalidGroupKeyError(`Group key must have a size of 256 bits, not ${maybeGroupKey.data.length * 8}`, maybeGroupKey);
        }
    }
    equals(other) {
        if (!(other instanceof GroupKey)) {
            return false;
        }
        return this === other || (this.hex === other.hex && this.id === other.id);
    }
    toString() {
        return this.id;
    }
    toArray() {
        return [this.id, this.hex];
    }
    serialize() {
        return JSON.stringify(this.toArray());
    }
    static generate(id = utils_1.uuid('GroupKey')) {
        const keyBytes = crypto_1.default.randomBytes(32);
        return new GroupKey(id, keyBytes);
    }
    static from(maybeGroupKey) {
        if (!maybeGroupKey || typeof maybeGroupKey !== 'object') {
            throw new InvalidGroupKeyError(`Group key must be object ${log_1.inspect(maybeGroupKey)}`);
        }
        if (maybeGroupKey instanceof GroupKey) {
            return maybeGroupKey;
        }
        try {
            if (Array.isArray(maybeGroupKey)) {
                return new GroupKey(maybeGroupKey[0], maybeGroupKey[1]);
            }
            const groupKeyObj = GroupKeyObjectFromProps(maybeGroupKey);
            return new GroupKey(groupKeyObj.id, groupKeyObj.hex || groupKeyObj.data);
        }
        catch (err) {
            if (err instanceof InvalidGroupKeyError) {
                // wrap err with logging of original object
                throw new InvalidGroupKeyError(`${err.stack}. From: ${log_1.inspect(maybeGroupKey)}`);
            }
            throw err;
        }
    }
}
exports.GroupKey = GroupKey;
GroupKey.InvalidGroupKeyError = InvalidGroupKeyError;
function ab2str(...args) {
    // @ts-ignore
    return String.fromCharCode.apply(null, new Uint8Array(...args));
}
// shim browser btoa for node
function btoa(str) {
    if (global.btoa) {
        return global.btoa(str);
    }
    let buffer;
    if (Buffer.isBuffer(str)) {
        buffer = str;
    }
    else {
        buffer = Buffer.from(str.toString(), 'binary');
    }
    return buffer.toString('base64');
}
async function exportCryptoKey(key, { isPrivate = false } = {}) {
    const WebCrypto = new node_webcrypto_ossl_1.Crypto();
    const keyType = isPrivate ? 'pkcs8' : 'spki';
    const exported = await WebCrypto.subtle.exportKey(keyType, key);
    const exportedAsString = ab2str(exported);
    const exportedAsBase64 = btoa(exportedAsString);
    const TYPE = isPrivate ? 'PRIVATE' : 'PUBLIC';
    return `-----BEGIN ${TYPE} KEY-----\n${exportedAsBase64}\n-----END ${TYPE} KEY-----\n`;
}
// put all static functions into EncryptionUtilBase, with exception of create,
// so it's clearer what the static & instance APIs look like
class EncryptionUtilBase {
    static validatePublicKey(publicKey) {
        const keyString = typeof publicKey === 'string' ? publicKey : publicKey.toString('utf8');
        if (typeof keyString !== 'string' || !keyString.startsWith('-----BEGIN PUBLIC KEY-----')
            || !keyString.endsWith('-----END PUBLIC KEY-----\n')) {
            throw new Error('"publicKey" must be a PKCS#8 RSA public key in the PEM format');
        }
    }
    static validatePrivateKey(privateKey) {
        const keyString = typeof privateKey === 'string' ? privateKey : privateKey.toString('utf8');
        if (typeof keyString !== 'string' || !keyString.startsWith('-----BEGIN PRIVATE KEY-----')
            || !keyString.endsWith('-----END PRIVATE KEY-----\n')) {
            throw new Error('"privateKey" must be a PKCS#8 RSA public key in the PEM format');
        }
    }
    static encryptWithPublicKey(plaintextBuffer, publicKey, outputInHex = false) {
        this.validatePublicKey(publicKey);
        const ciphertextBuffer = crypto_1.default.publicEncrypt(publicKey, plaintextBuffer);
        if (outputInHex) {
            return bytes_1.hexlify(ciphertextBuffer).slice(2);
        }
        return ciphertextBuffer;
    }
    /* eslint-disable no-dupe-class-members */
    /*
     * Both 'data' and 'groupKey' must be Buffers. Returns a hex string without the '0x' prefix.
     */
    static encrypt(data, groupKey) {
        GroupKey.validate(groupKey);
        const iv = crypto_1.default.randomBytes(16); // always need a fresh IV when using CTR mode
        const cipher = crypto_1.default.createCipheriv('aes-256-ctr', groupKey.data, iv);
        return bytes_1.hexlify(iv).slice(2) + cipher.update(data, undefined, 'hex') + cipher.final('hex');
    }
    /*
     * 'ciphertext' must be a hex string (without '0x' prefix), 'groupKey' must be a GroupKey. Returns a Buffer.
     */
    static decrypt(ciphertext, groupKey) {
        GroupKey.validate(groupKey);
        const iv = bytes_1.arrayify(`0x${ciphertext.slice(0, 32)}`);
        const decipher = crypto_1.default.createDecipheriv('aes-256-ctr', groupKey.data, iv);
        return Buffer.concat([decipher.update(ciphertext.slice(32), 'hex'), decipher.final()]);
    }
    /*
     * Sets the content of 'streamMessage' with the encryption result of the old content with 'groupKey'.
     */
    static encryptStreamMessage(streamMessage, groupKey, nextGroupKey) {
        GroupKey.validate(groupKey);
        /* eslint-disable no-param-reassign */
        streamMessage.encryptionType = StreamMessage.ENCRYPTION_TYPES.AES;
        streamMessage.groupKeyId = groupKey.id;
        if (nextGroupKey) {
            GroupKey.validate(nextGroupKey);
            // @ts-expect-error
            streamMessage.newGroupKey = nextGroupKey;
        }
        streamMessage.serializedContent = this.encrypt(Buffer.from(streamMessage.getSerializedContent(), 'utf8'), groupKey);
        if (nextGroupKey) {
            GroupKey.validate(nextGroupKey);
            streamMessage.newGroupKey = new EncryptedGroupKey(nextGroupKey.id, this.encrypt(nextGroupKey.data, groupKey));
        }
        streamMessage.parsedContent = undefined;
        /* eslint-enable no-param-reassign */
    }
    /*
     * Decrypts the serialized content of 'streamMessage' with 'groupKey'. If the resulting plaintext is the concatenation
     * of a new group key and a message content, sets the content of 'streamMessage' with that message content and returns
     * the key. If the resulting plaintext is only a message content, sets the content of 'streamMessage' with that
     * message content and returns null.
     */
    static decryptStreamMessage(streamMessage, groupKey) {
        if ((streamMessage.encryptionType !== StreamMessage.ENCRYPTION_TYPES.AES)) {
            return null;
        }
        try {
            GroupKey.validate(groupKey);
        }
        catch (err) {
            throw new UnableToDecryptError(`${err.message}`, streamMessage);
        }
        /* eslint-disable no-param-reassign */
        try {
            streamMessage.encryptionType = StreamMessage.ENCRYPTION_TYPES.NONE;
            const serializedContent = this.decrypt(streamMessage.getSerializedContent(), groupKey).toString();
            streamMessage.parsedContent = JSON.parse(serializedContent);
            streamMessage.serializedContent = serializedContent;
        }
        catch (err) {
            streamMessage.encryptionType = StreamMessage.ENCRYPTION_TYPES.AES;
            throw new UnableToDecryptError(err.stack, streamMessage);
        }
        try {
            const { newGroupKey } = streamMessage;
            if (newGroupKey) {
                // newGroupKey should be EncryptedGroupKey | GroupKey, but GroupKey is not defined in protocol
                // @ts-expect-error
                streamMessage.newGroupKey = GroupKey.from([
                    newGroupKey.groupKeyId,
                    this.decrypt(newGroupKey.encryptedGroupKeyHex, groupKey)
                ]);
            }
        }
        catch (err) {
            streamMessage.encryptionType = StreamMessage.ENCRYPTION_TYPES.AES;
            throw new UnableToDecryptError('Could not decrypt new group key: ' + err.stack, streamMessage);
        }
        return null;
        /* eslint-enable no-param-reassign */
    }
}
/** @internal */
class EncryptionUtil extends EncryptionUtilBase {
    constructor(options = {}) {
        super();
        if ('privateKey' in options && 'publicKey' in options) {
            EncryptionUtil.validatePrivateKey(options.privateKey);
            EncryptionUtil.validatePublicKey(options.publicKey);
            this.privateKey = options.privateKey;
            this.publicKey = options.publicKey;
        }
    }
    /**
     * Creates a new instance + waits for ready.
     * Convenience.
     */
    static async create(...args) {
        const encryptionUtil = new EncryptionUtil(...args);
        await encryptionUtil.onReady();
        return encryptionUtil;
    }
    async onReady() {
        if (this.isReady()) {
            return undefined;
        }
        return this._generateKeyPair();
    }
    isReady() {
        return !!(this.privateKey && this.publicKey);
    }
    // Returns a Buffer
    decryptWithPrivateKey(ciphertext, isHexString = false) {
        if (!this.isReady()) {
            throw new Error('EncryptionUtil not ready.');
        }
        const ciphertextBuffer = isHexString ? bytes_1.arrayify(`0x${ciphertext}`) : ciphertext;
        return crypto_1.default.privateDecrypt(this.privateKey, ciphertextBuffer);
    }
    // Returns a String (base64 encoding)
    getPublicKey() {
        if (!this.isReady()) {
            throw new Error('EncryptionUtil not ready.');
        }
        return this.publicKey;
    }
    async _generateKeyPair() {
        if (!this._generateKeyPairPromise) {
            this._generateKeyPairPromise = this.__generateKeyPair();
        }
        return this._generateKeyPairPromise;
    }
    async __generateKeyPair() {
        if (typeof window !== 'undefined') {
            return this._keyPairBrowser();
        }
        return this._keyPairServer();
    }
    async _keyPairServer() {
        // promisify here to work around browser/server packaging
        const generateKeyPair = util_1.promisify(crypto_1.default.generateKeyPair);
        const { publicKey, privateKey } = await generateKeyPair('rsa', {
            modulusLength: 4096,
            publicKeyEncoding: {
                type: 'spki',
                format: 'pem',
            },
            privateKeyEncoding: {
                type: 'pkcs8',
                format: 'pem',
            },
        });
        this.privateKey = privateKey;
        this.publicKey = publicKey;
    }
    async _keyPairBrowser() {
        const WebCrypto = new node_webcrypto_ossl_1.Crypto();
        const { publicKey, privateKey } = await WebCrypto.subtle.generateKey({
            name: 'RSA-OAEP',
            modulusLength: 4096,
            publicExponent: new Uint8Array([1, 0, 1]),
            hash: 'SHA-256'
        }, true, ['encrypt', 'decrypt']);
        const [exportedPrivate, exportedPublic] = await Promise.all([
            exportCryptoKey(privateKey, {
                isPrivate: true,
            }),
            exportCryptoKey(publicKey, {
                isPrivate: false,
            })
        ]);
        this.privateKey = exportedPrivate;
        this.publicKey = exportedPublic;
    }
}
exports.default = EncryptionUtil;
//# sourceMappingURL=Encryption.js.map