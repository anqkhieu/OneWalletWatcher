"use strict";
/**
 * Utilities shared between publish & subscribe
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.createStreamId = exports.waitForRequestResponse = exports.waitForResponse = exports.waitForMatchingMessage = exports.STREAM_MESSAGE_TYPES = exports.validateOptions = exports.StreamKey = void 0;
const util_1 = require("util");
const streamr_client_protocol_1 = require("streamr-client-protocol");
const utils_1 = require("../utils");
function StreamKey({ streamId, streamPartition = 0 }) {
    if (streamId == null) {
        throw new Error(`StreamKey: invalid streamId (${typeof streamId}): ${streamId}`);
    }
    if (!Number.isInteger(streamPartition) || streamPartition < 0) {
        throw new Error(`StreamKey: invalid streamPartition (${typeof streamPartition}): ${streamPartition}`);
    }
    return `${streamId}::${streamPartition}`;
}
exports.StreamKey = StreamKey;
function validateOptions(optionsOrStreamId) {
    if (!optionsOrStreamId) {
        throw new Error('streamId is required!');
    }
    // Backwards compatibility for giving a streamId as first argument
    let options = {};
    if (typeof optionsOrStreamId === 'string') {
        options = {
            streamId: optionsOrStreamId,
            streamPartition: 0,
        };
    }
    else if (typeof optionsOrStreamId === 'object') {
        if (optionsOrStreamId.stream) {
            const { stream, ...other } = optionsOrStreamId;
            return validateOptions({
                ...other,
                ...validateOptions(stream),
            });
        }
        if (optionsOrStreamId.id != null && optionsOrStreamId.streamId == null) {
            options.streamId = optionsOrStreamId.id;
        }
        if (optionsOrStreamId.partition != null && optionsOrStreamId.streamPartition == null) {
            options.streamPartition = optionsOrStreamId.partition;
        }
        // shallow copy
        options = {
            streamPartition: 0,
            ...options,
            ...optionsOrStreamId
        };
    }
    else {
        throw new Error(`options must be an object! Given: ${util_1.inspect(optionsOrStreamId)}`);
    }
    if (options.streamId == null) {
        throw new Error(`streamId must be set! Given: ${util_1.inspect(optionsOrStreamId)}`);
    }
    options.streamPartition = options.streamPartition || 0;
    options.key = StreamKey(options);
    return options;
}
exports.validateOptions = validateOptions;
const { ControlMessage } = streamr_client_protocol_1.ControlLayer;
const ResendResponses = [ControlMessage.TYPES.ResendResponseResending, ControlMessage.TYPES.ResendResponseNoResend];
exports.STREAM_MESSAGE_TYPES = [ControlMessage.TYPES.UnicastMessage, ControlMessage.TYPES.BroadcastMessage];
const PAIRS = new Map([
    [ControlMessage.TYPES.SubscribeRequest, [ControlMessage.TYPES.SubscribeResponse]],
    [ControlMessage.TYPES.UnsubscribeRequest, [ControlMessage.TYPES.UnsubscribeResponse]],
    [ControlMessage.TYPES.ResendLastRequest, ResendResponses],
    [ControlMessage.TYPES.ResendFromRequest, ResendResponses],
    [ControlMessage.TYPES.ResendRangeRequest, ResendResponses],
]);
async function waitForMatchingMessage({ connection, matchFn, timeout, types = [], rejectOnTimeout = true, timeoutMessage, cancelTask, }) {
    let callError = new Error('waitForMatchingMessage Error');
    if (typeof matchFn !== 'function') {
        throw new Error(`matchFn required, got: (${typeof matchFn}) ${matchFn}`);
    }
    await connection.nextConnection();
    let done = () => { };
    const matchTask = new Promise((resolve, reject) => {
        const tryMatch = (...args) => {
            try {
                return matchFn(...args);
            }
            catch (err) {
                done(err);
                return false;
            }
        };
        const onResponse = (res) => {
            if (!tryMatch(res)) {
                return;
            }
            // clean up err handler
            done(undefined, res);
        };
        const onErrorResponse = (res) => {
            if (!tryMatch(res)) {
                return;
            }
            // clean up success handler
            const error = callError || new Error('waitForMatchingMessage Error');
            error.message += `: ${res.errorMessage}`;
            // @ts-expect-error
            error.code = res.errorCode;
            done(error);
        };
        let onDisconnected;
        done = (err, value) => {
            callError = undefined;
            // eslint-disable-next-line promise/no-promise-in-callback
            if (cancelTask) {
                cancelTask.catch(() => { });
            } // ignore cancel errors
            connection.off('disconnected', onDisconnected);
            connection.off('done', onDisconnected);
            connection.off(ControlMessage.TYPES.ErrorResponse, onErrorResponse);
            types.forEach((type) => {
                connection.off(type, onResponse);
            });
            if (err) {
                reject(err);
            }
            else {
                resolve(value);
            }
        };
        onDisconnected = () => done();
        connection.once('disconnected', onDisconnected);
        connection.once('done', onDisconnected);
        types.forEach((type) => {
            connection.on(type, onResponse);
        });
        connection.once(ControlMessage.TYPES.ErrorResponse, onErrorResponse);
    });
    try {
        const task = cancelTask ? Promise.race([
            matchTask,
            cancelTask,
        ]) : matchTask;
        if (!timeout) {
            return await task;
        }
        return await utils_1.pTimeout(task, {
            timeout,
            message: timeoutMessage,
            rejectOnTimeout,
        });
    }
    finally {
        done();
    }
}
exports.waitForMatchingMessage = waitForMatchingMessage;
/**
 * Wait for matching response types to requestId, or ErrorResponse.
 */
async function waitForResponse({ requestId, timeoutMessage = `Waiting for response to: ${requestId}.`, ...opts }) {
    if (requestId == null) {
        throw new Error(`requestId required, got: (${typeof requestId}) ${requestId}`);
    }
    return waitForMatchingMessage({
        ...opts,
        requestId,
        timeoutMessage,
        matchFn(res) {
            return res.requestId === requestId;
        }
    });
}
exports.waitForResponse = waitForResponse;
async function waitForRequestResponse(client, request, opts = {}) {
    return waitForResponse({
        connection: client.connection,
        types: PAIRS.get(request.type),
        requestId: request.requestId,
        ...opts, // e.g. timeout, rejectOnTimeout
    });
}
exports.waitForRequestResponse = waitForRequestResponse;
const createStreamId = async (streamIdOrPath, ownerProvider) => {
    if (streamIdOrPath === undefined) {
        throw new Error('Missing stream id');
    }
    if (!streamIdOrPath.startsWith('/')) {
        return streamIdOrPath;
    }
    if (ownerProvider === undefined) {
        throw new Error(`Owner provider missing for stream id: ${streamIdOrPath}`);
    }
    const owner = await ownerProvider();
    if (owner === undefined) {
        throw new Error(`Owner missing for stream id: ${streamIdOrPath}`);
    }
    return owner.toLowerCase() + streamIdOrPath;
};
exports.createStreamId = createStreamId;
//# sourceMappingURL=utils.js.map