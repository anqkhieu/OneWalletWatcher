"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const streamr_client_protocol_1 = require("streamr-client-protocol");
const mem_1 = __importDefault(require("mem"));
const utils_1 = require("../utils");
const Signer_1 = __importDefault(require("./Signer"));
const Encrypt_1 = __importDefault(require("./Encrypt"));
const MessageChainer_1 = __importDefault(require("./MessageChainer"));
const StreamPartitioner_1 = __importDefault(require("./StreamPartitioner"));
const utils_2 = require("./utils");
class StreamMessageCreator {
    /*
     * Get function for creating stream messages.
     */
    constructor(client) {
        const cacheOptions = client.options.cache;
        this.client = client;
        this.computeStreamPartition = StreamPartitioner_1.default(cacheOptions);
        this.encrypt = Encrypt_1.default(client);
        // one chainer per streamId + streamPartition + publisherId + msgChainId
        this.getMsgChainer = Object.assign(mem_1.default(MessageChainer_1.default, {
            cacheKey: ([{ streamId, streamPartition, publisherId, msgChainId }]) => (
            // undefined msgChainId is fine
            [streamId, streamPartition, publisherId, msgChainId].join('|')),
            ...cacheOptions,
            maxAge: undefined
        }), {
            clear: () => {
                mem_1.default.clear(this.getMsgChainer);
            }
        });
        // message signer
        this.signStreamMessage = Signer_1.default({
            ...client.options.auth,
        }, client.options.publishWithSignature);
        // per-stream queue so messages processed in-order
        this.queue = utils_1.LimitAsyncFnByKey(1);
    }
    async create(streamObjectOrId, { content, timestamp, partitionKey, msgChainId, ...opts }) {
        const streamId = utils_2.getStreamId(streamObjectOrId);
        // streamId as queue key
        return this.queue(streamId, async () => {
            // load cached stream + publisher details
            const [stream, publisherId] = await Promise.all([
                this.client.cached.getStream(streamId),
                this.client.cached.getUserId(this.client),
            ]);
            // figure out partition
            const definedPartition = utils_2.getStreamPartition(streamObjectOrId);
            if ((definedPartition !== undefined) && (partitionKey !== undefined)) {
                throw new Error('Invalid combination of "partition" and "partitionKey"');
            }
            const streamPartition = definedPartition !== null && definedPartition !== void 0 ? definedPartition : this.computeStreamPartition(stream.partitions, partitionKey !== null && partitionKey !== void 0 ? partitionKey : 0);
            // chain messages
            const chainMessage = this.getMsgChainer({
                streamId, streamPartition, publisherId, msgChainId
            });
            const timestampAsNumber = timestamp instanceof Date ? timestamp.getTime() : new Date(timestamp).getTime();
            const [messageId, prevMsgRef] = chainMessage(timestampAsNumber);
            const streamMessage = (content && typeof content.toStreamMessage === 'function')
                ? content.toStreamMessage(messageId, prevMsgRef)
                : new streamr_client_protocol_1.StreamMessage({
                    messageId,
                    prevMsgRef,
                    content,
                    ...opts
                });
            await this.encrypt(streamMessage, stream);
            // sign, noop if not needed
            await this.signStreamMessage(streamMessage);
            return streamMessage;
        });
    }
    setNextGroupKey(maybeStreamId, newKey) {
        return this.encrypt.setNextGroupKey(maybeStreamId, newKey);
    }
    rotateGroupKey(maybeStreamId) {
        return this.encrypt.rotateGroupKey(maybeStreamId);
    }
    rekey(maybeStreamId) {
        return this.encrypt.rekey(maybeStreamId);
    }
    startKeyExchange() {
        return this.encrypt.start();
    }
    async stop() {
        this.computeStreamPartition.clear();
        this.queue.clear();
        this.getMsgChainer.clear();
        await this.encrypt.stop();
    }
}
exports.default = StreamMessageCreator;
//# sourceMappingURL=MessageCreator.js.map