"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getUserId = exports.getAddressFromOptions = void 0;
const transactions_1 = require("@ethersproject/transactions");
const providers_1 = require("@ethersproject/providers");
const bytes_1 = require("@ethersproject/bytes");
const sha2_1 = require("@ethersproject/sha2");
async function getUsername(client) {
    const { options: { auth = {} } = {} } = client;
    if (auth.username) {
        return auth.username;
    }
    const { username, id } = await client.cached.getUserInfo();
    return (username
        // edge case: if auth.apiKey is an anonymous key, userInfo.id is that anonymous key
        // update: not sure if still needed now that apiKey auth has been disabled
        || id);
}
async function getAddressFromOptions({ ethereum, privateKey } = {}) {
    if (privateKey) {
        return transactions_1.computeAddress(privateKey).toLowerCase();
    }
    if (ethereum) {
        const provider = new providers_1.Web3Provider(ethereum);
        const address = await provider.getSigner().getAddress();
        return address.toLowerCase();
    }
    throw new Error('Need either "privateKey" or "ethereum".');
}
exports.getAddressFromOptions = getAddressFromOptions;
async function getUserId(client) {
    if (client.session.isUnauthenticated()) {
        throw new Error('Need to be authenticated to getUserId.');
    }
    const { options: { auth = {} } = {} } = client;
    if (auth.ethereum || auth.privateKey) {
        return getAddressFromOptions(auth);
    }
    const username = await getUsername(client);
    if (username != null) {
        const hexString = bytes_1.hexlify(Buffer.from(username, 'utf8'));
        return sha2_1.sha256(hexString);
    }
    throw new Error('Need either "privateKey", "ethereum" or "sessionToken" to derive the publisher Id.');
}
exports.getUserId = getUserId;
//# sourceMappingURL=index.js.map