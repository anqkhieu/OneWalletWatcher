/**
 * @see {@link StreamrClient.StreamrClient}
 * @module StreamrClient
 */
import EventEmitter from 'eventemitter3';
import { ControlLayer } from 'streamr-client-protocol';
import { Debugger } from './utils/log';
import { StreamrClientOptions, StrictStreamrClientOptions } from './Config';
import Session from './Session';
import Connection, { ConnectionOptions } from './Connection';
import Publisher from './publish';
import { Subscriber, Subscription } from './subscribe';
import { EthereumAddress, MaybeAsync, Todo } from './types';
import { StreamEndpoints } from './rest/StreamEndpoints';
import { LoginEndpoints } from './rest/LoginEndpoints';
import { DataUnion, DataUnionDeployOptions } from './dataunion/DataUnion';
import { BigNumber } from '@ethersproject/bignumber';
import { GroupKey, StreamPartDefinition } from './stream';
import { BytesLike } from '@ethersproject/bytes';
export declare type OnMessageCallback = MaybeAsync<(message: any, metadata: any) => void>;
export declare type ResendOptions = {
    from?: {
        timestamp: number;
        sequenceNumber?: number;
    };
    to?: {
        timestamp: number;
        sequenceNumber?: number;
    };
    last?: number;
};
export declare type SubscribeOptions = {
    resend?: ResendOptions;
} & ResendOptions;
interface MessageEvent {
    data: any;
}
/**
 * Wrap connection message events with message parsing.
 */
declare class StreamrConnection extends Connection {
    constructor(options: ConnectionOptions, debug?: Debugger);
    parse(messageEvent: MessageEvent): ControlLayer.ControlMessage;
    onConnectionMessage(messageEvent: MessageEvent): void;
}
export interface StreamrClient extends StreamEndpoints, LoginEndpoints, Publisher, Subscriber {
}
/**
 * @category Important
 */
export declare class StreamrClient extends EventEmitter {
    options: StrictStreamrClientOptions;
    session: Session;
    constructor(options?: StreamrClientOptions, connection?: StreamrConnection);
    enableDebugLogging(prefix?: string): void;
    disableDebugLogging(): void;
    stop(): Promise<void>;
    /**
     * Override to control output
     */
    onError(error: Error): void;
    isConnected(): boolean;
    isConnecting(): boolean;
    isDisconnecting(): boolean;
    isDisconnected(): boolean;
    /**
     * @category Important
     */
    connect(): Promise<void>;
    nextConnection(): Promise<void>;
    /**
     * @category Important
     */
    disconnect(): Promise<void>;
    getSubscriptions(): Subscription[];
    getSubscription(definition: StreamPartDefinition): Subscription[];
    ensureConnected(): Promise<void>;
    ensureDisconnected(): Promise<void>;
    logout(): Promise<void>;
    /**
     * @category Important
     */
    publish(streamObjectOrId: StreamPartDefinition, content: object, timestamp?: number | string | Date, partitionKey?: string): Promise<ControlLayer.PublishRequest>;
    getUserId(): Promise<string>;
    setNextGroupKey(streamId: string, newKey: GroupKey): Promise<void>;
    rotateGroupKey(streamId: string): Promise<void>;
    rekey(streamId: string): Promise<void>;
    /**
     * @category Important
     */
    subscribe(opts: SubscribeOptions & StreamPartDefinition, onMessage?: OnMessageCallback): Promise<Subscription>;
    /**
     * @category Important
     */
    unsubscribe(subscription: Subscription | SubscribeOptions & StreamPartDefinition): Promise<void>;
    /**
     * @category Important
     */
    resend(opts: Todo, onMessage?: OnMessageCallback): Promise<Subscription>;
    enableAutoConnect(autoConnect?: boolean): void;
    enableAutoDisconnect(autoDisconnect?: boolean): void;
    getAddress(): Promise<EthereumAddress>;
    getPublisherId(): Promise<EthereumAddress>;
    /**
     * True if authenticated with private key/ethereum provider
     */
    canEncrypt(): boolean;
    /**
     * Get token balance in "wei" (10^-18 parts) for given address
     */
    getTokenBalance(address: EthereumAddress): Promise<BigNumber>;
    /**
     * Get token balance in "wei" (10^-18 parts) for given address in sidechain
     */
    getSidechainTokenBalance(address: EthereumAddress): Promise<BigNumber>;
    getDataUnion(contractAddress: EthereumAddress): DataUnion;
    safeGetDataUnion(contractAddress: EthereumAddress): Promise<DataUnion>;
    deployDataUnion(options?: DataUnionDeployOptions): Promise<DataUnion>;
    setBinanceDepositAddress(binanceRecipient: EthereumAddress): Promise<any>;
    setBinanceDepositAddressFromSignature(from: EthereumAddress, binanceRecipient: EthereumAddress, signature: BytesLike): Promise<any>;
    setBinanceDepositAddressViaWithdrawServer(from: EthereumAddress, binanceRecipient: EthereumAddress, signature: BytesLike): Promise<object>;
    getBinanceDepositAddress(userAddress: EthereumAddress): Promise<any>;
    signSetBinanceRecipient(recipientAddress: EthereumAddress): Promise<string>;
    /**
     * @category Important
     */
    static generateEthereumAccount(): {
        address: string;
        privateKey: string;
    };
}
export {};
