"use strict";
/**
 * @module StreamrClientConfig
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.STREAM_CLIENT_DEFAULTS = void 0;
const qs_1 = __importDefault(require("qs"));
const streamr_client_protocol_1 = require("streamr-client-protocol");
const utils_1 = require("./utils");
const address_1 = require("@ethersproject/address");
const has_1 = __importDefault(require("lodash/has"));
const get_1 = __importDefault(require("lodash/get"));
const StorageNode_1 = require("./stream/StorageNode");
const { ControlMessage } = streamr_client_protocol_1.ControlLayer;
const { StreamMessage } = streamr_client_protocol_1.MessageLayer;
const validateOverridedEthereumAddresses = (opts, propertyPaths) => {
    for (const propertyPath of propertyPaths) {
        if (has_1.default(opts, propertyPath)) {
            const value = get_1.default(opts, propertyPath);
            if (!address_1.isAddress(value)) {
                throw new Error(`${propertyPath} is not a valid Ethereum address`);
            }
        }
    }
};
/**
 * @category Important
 */
exports.STREAM_CLIENT_DEFAULTS = {
    auth: {},
    // Streamr Core options
    url: 'wss://streamr.network/api/v1/ws',
    restUrl: 'https://streamr.network/api/v1',
    streamrNodeAddress: '0xf3E5A65851C3779f468c9EcB32E6f25D9D68601a',
    // P2P Streamr Network options
    autoConnect: true,
    autoDisconnect: true,
    orderMessages: true,
    retryResendAfter: 5000,
    gapFillTimeout: 5000,
    maxGapRequests: 5,
    maxRetries: 5,
    maxPublishQueueSize: 10000,
    publishAutoDisconnectDelay: 5000,
    // Encryption options
    publishWithSignature: 'auto',
    verifySignatures: 'auto',
    publisherStoreKeyHistory: true,
    groupKeys: {},
    keyExchange: {},
    // Ethereum and Data Union related options
    // For ethers.js provider params, see https://docs.ethers.io/ethers.js/v5-beta/api-providers.html#provider
    mainnet: undefined,
    sidechain: {
        url: 'https://rpc.xdaichain.com/',
        chainId: 100
    },
    binanceRPC: {
        url: 'https://bsc-dataseed.binance.org/',
        chainId: 56
    },
    tokenAddress: '0x0Cf0Ee63788A0849fE5297F3407f701E122cC023',
    tokenSidechainAddress: '0xE4a2620edE1058D61BEe5F45F6414314fdf10548',
    binanceAdapterAddress: '0x0c1aF6edA561fbDA48E9A7B1Dd46D216F31A97cC',
    binanceSmartChainAMBAddress: '0x05185872898b6f94aa600177ef41b9334b1fa48b',
    withdrawServerUrl: 'https://streamr.com:3000',
    dataUnion: {
        minimumWithdrawTokenWei: '1000000',
        payForTransport: true,
        factoryMainnetAddress: '0x7d55f9981d4E10A193314E001b96f72FCc901e40',
        factorySidechainAddress: '0x1b55587Beea0b5Bc96Bb2ADa56bD692870522e9f',
        templateMainnetAddress: '0x5FE790E3751dd775Cb92e9086Acd34a2adeB8C7b',
        templateSidechainAddress: '0xf1E9d6E254BeA3f0129018AcA1A50AEcb7D528be',
    },
    storageNode: {
        address: StorageNode_1.StorageNode.STREAMR_GERMANY.getAddress(),
        url: 'https://corea1.streamr.network:8001'
    },
    cache: {
        maxSize: 10000,
        maxAge: 30 * 60 * 1000, // 30 minutes
    }
};
/** @internal */
function ClientConfig(opts = {}) {
    // validate all Ethereum addresses which are required in StrictStreamrClientOptions: if user
    // overrides a setting, which has a default value, it must be a non-null valid Ethereum address
    // TODO could also validate
    // - other optional Ethereum address (if there will be some)
    // - other overriden options (e.g. regexp check that "restUrl" is a valid url)
    validateOverridedEthereumAddresses(opts, [
        'streamrNodeAddress',
        'tokenAddress',
        'tokenSidechainAddress',
        'dataUnion.factoryMainnetAddress',
        'dataUnion.factorySidechainAddress',
        'dataUnion.templateMainnetAddress',
        'dataUnion.templateSidechainAddress',
        'storageNode.address'
    ]);
    const options = {
        ...exports.STREAM_CLIENT_DEFAULTS,
        ...opts,
        dataUnion: {
            ...exports.STREAM_CLIENT_DEFAULTS.dataUnion,
            ...opts.dataUnion
        },
        cache: {
            ...exports.STREAM_CLIENT_DEFAULTS.cache,
            ...opts.cache,
        }
        // NOTE: sidechain and storageNode settings are not merged with the defaults
    };
    const parts = options.url.split('?');
    if (parts.length === 1) { // there is no query string
        const controlLayer = `controlLayerVersion=${ControlMessage.LATEST_VERSION}`;
        const messageLayer = `messageLayerVersion=${StreamMessage.LATEST_VERSION}`;
        options.url = `${options.url}?${controlLayer}&${messageLayer}`;
    }
    else {
        const queryObj = qs_1.default.parse(parts[1]);
        if (!queryObj.controlLayerVersion) {
            options.url = `${options.url}&controlLayerVersion=1`;
        }
        if (!queryObj.messageLayerVersion) {
            options.url = `${options.url}&messageLayerVersion=31`;
        }
    }
    // always add streamrClient version
    options.url = `${options.url}&streamrClient=${utils_1.getVersionString()}`;
    // Backwards compatibility for option 'authKey' => 'apiKey'
    // @ts-expect-error
    if (options.authKey && !options.apiKey) {
        // @ts-expect-error
        options.apiKey = options.authKey;
    }
    // @ts-expect-error
    if (options.apiKey) {
        // @ts-expect-error
        options.auth.apiKey = options.apiKey;
    }
    options.auth = options.auth || {};
    if ('privateKey' in options.auth) {
        const { privateKey } = options.auth;
        if (typeof privateKey === 'string' && !privateKey.startsWith('0x')) {
            options.auth.privateKey = `0x${options.auth.privateKey}`;
        }
    }
    return options;
}
exports.default = ClientConfig;
//# sourceMappingURL=Config.js.map