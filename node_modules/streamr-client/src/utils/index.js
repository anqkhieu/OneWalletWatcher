"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.until = exports.sleep = exports.allSettledValues = exports.pTimeout = exports.TimeoutError = exports.pOnce = exports.pOne = exports.pLimitFn = exports.pOrderedResolve = exports.LimitAsyncFnByKey = exports.Defer = exports.CacheFn = exports.CacheAsyncFn = exports.getEndpointUrl = exports.waitFor = exports.getVersionString = exports.counterId = exports.CounterId = exports.randomString = exports.Scaffold = exports.AggregatedError = exports.uuid = void 0;
const util_1 = require("util");
const uuid_1 = require("./uuid");
const p_memoize_1 = __importDefault(require("p-memoize"));
const p_limit_1 = __importDefault(require("p-limit"));
const mem_1 = __importDefault(require("mem"));
const package_json_1 = __importDefault(require("../../package.json"));
const quick_lru_1 = __importDefault(require("../../vendor/quick-lru"));
const AggregatedError_1 = __importDefault(require("./AggregatedError"));
exports.AggregatedError = AggregatedError_1.default;
const Scaffold_1 = __importDefault(require("./Scaffold"));
exports.Scaffold = Scaffold_1.default;
var uuid_2 = require("./uuid");
Object.defineProperty(exports, "uuid", { enumerable: true, get: function () { return __importDefault(uuid_2).default; } });
function randomString(length = 20) {
    // eslint-disable-next-line no-bitwise
    return [...Array(length)].map(() => (~~(Math.random() * 36)).toString(36)).join('');
}
exports.randomString = randomString;
/**
 * Generates counter-based ids.
 * Basically lodash.uniqueid but per-prefix.
 * Not universally unique.
 * Generally useful for tracking instances.
 *
 * Careful not to use too many prefixes since it needs to hold all prefixes in memory
 * e.g. don't pass new uuid as a prefix
 *
 * counterId('test') => test.0
 * counterId('test') => test.1
 */
const CounterId = (rootPrefix, { maxPrefixes = 256 } = {}) => {
    let counts = {}; // possible we could switch this to WeakMap and pass functions or classes.
    let didWarn = false;
    const counterIdFn = (prefix = 'ID', separator = uuid_1.SEPARATOR) => {
        // pedantic: wrap around if count grows too large
        counts[prefix] = (counts[prefix] + 1 || 0) % Number.MAX_SAFE_INTEGER;
        // warn once if too many prefixes
        if (!didWarn) {
            const numTracked = Object.keys(counts).length;
            if (numTracked > maxPrefixes) {
                didWarn = true;
                console.warn(`counterId should not be used for a large number of unique prefixes: ${numTracked} > ${maxPrefixes}`);
            }
        }
        // connect prefix with separator
        return [rootPrefix, prefix, counts[prefix]]
            .filter((v) => v != null) // remove {root}Prefix if not set
            .join(separator);
    };
    /**
     * Clears counts for prefix or all if no prefix supplied.
     *
     * @param {string?} prefix
     */
    counterIdFn.clear = (...args) => {
        // check length to differentiate between clear(undefined) & clear()
        if (args.length) {
            const [prefix] = args;
            delete counts[prefix];
        }
        else {
            // clear all
            counts = {};
        }
    };
    return counterIdFn;
};
exports.CounterId = CounterId;
exports.counterId = exports.CounterId();
function getVersion() {
    // dev deps are removed for production build
    const hasDevDependencies = !!(package_json_1.default.devDependencies && Object.keys(package_json_1.default.devDependencies).length);
    const isProduction = process.env.NODE_ENV === 'production' || hasDevDependencies;
    return `${package_json_1.default.version}${!isProduction ? 'dev' : ''}`;
}
// hardcode this at module exec time as can't change
const versionString = getVersion();
function getVersionString() {
    return versionString;
}
exports.getVersionString = getVersionString;
/**
 * Converts a .once event listener into a promise.
 * Rejects if an 'error' event is received before resolving.
 */
function waitFor(emitter, event) {
    return new Promise((resolve, reject) => {
        let onError;
        const onEvent = (value) => {
            emitter.off('error', onError);
            resolve(value);
        };
        onError = (error) => {
            emitter.off(event, onEvent);
            reject(error);
        };
        emitter.once(event, onEvent);
        emitter.once('error', onError);
    });
}
exports.waitFor = waitFor;
const getEndpointUrl = (baseUrl, ...pathParts) => {
    return baseUrl + '/' + pathParts.map((part) => encodeURIComponent(part)).join('/');
};
exports.getEndpointUrl = getEndpointUrl;
function clearMatching(cache, matchFn) {
    for (const key of cache.keys()) {
        if (matchFn(key)) {
            cache.delete(key);
        }
    }
}
function CacheAsyncFn(asyncFn, { maxSize = 10000, maxAge = 30 * 60 * 1000, // 30 minutes
cachePromiseRejection = false, onEviction = () => { }, ...opts } = {}) {
    const cache = new quick_lru_1.default({
        maxSize,
        maxAge,
        onEviction,
    });
    const cachedFn = Object.assign(p_memoize_1.default(asyncFn, {
        cachePromiseRejection,
        cache,
        ...opts,
    }), {
        clear: () => {
            p_memoize_1.default.clear(cachedFn);
            cache.clear();
        },
        clearMatching: (...args) => clearMatching(cache, ...args),
    });
    return cachedFn;
}
exports.CacheAsyncFn = CacheAsyncFn;
function CacheFn(fn, { maxSize = 10000, maxAge = 30 * 60 * 1000, // 30 minutes
onEviction = () => { }, ...opts } = {}) {
    const cache = new quick_lru_1.default({
        maxSize,
        maxAge,
        onEviction,
    });
    const cachedFn = Object.assign(mem_1.default(fn, {
        maxAge,
        cache,
        ...opts,
    }), {
        clear: () => mem_1.default.clear(cachedFn),
        clearMatching: (...args) => clearMatching(cache, ...args),
    });
    return cachedFn;
}
exports.CacheFn = CacheFn;
const noop = () => { };
function Defer(executor = noop) {
    let resolveFn;
    let rejectFn;
    const resolve = (value) => {
        if (resolveFn) {
            const r = resolveFn;
            resolveFn = undefined;
            rejectFn = undefined;
            r(value);
        }
    };
    const reject = (error) => {
        if (rejectFn) {
            const r = rejectFn;
            resolveFn = undefined;
            rejectFn = undefined;
            r(error);
        }
    };
    // eslint-disable-next-line promise/param-names
    const p = new Promise((_resolve, _reject) => {
        resolveFn = _resolve;
        rejectFn = _reject;
        executor(resolve, reject);
    });
    p.catch(() => { }); // prevent unhandledrejection
    function wrap(fn) {
        return async (...args) => {
            try {
                return resolve(await fn(...args));
            }
            catch (err) {
                reject(err);
            }
            return Promise.resolve();
        };
    }
    function wrapError(fn) {
        return async (...args) => {
            try {
                return await fn(...args);
            }
            catch (err) {
                reject(err);
            }
            return Promise.resolve();
        };
    }
    function handleErrBack(err) {
        if (err) {
            reject(err);
        }
        else {
            resolve(undefined);
        }
    }
    return Object.assign(p, {
        resolve,
        reject,
        wrap,
        wrapError,
        handleErrBack
    });
}
exports.Defer = Defer;
function LimitAsyncFnByKey(limit = 1) {
    const pending = new Map();
    const f = async (id, fn) => {
        const limitFn = (pending.get(id) || pending.set(id, p_limit_1.default(limit)).get(id));
        try {
            return await limitFn(fn);
        }
        finally {
            if (!limitFn.activeCount && !limitFn.pendingCount) {
                if (pending.get(id) === limitFn) {
                    // clean up if no more active entries (if not cleared)
                    pending.delete(id);
                }
            }
        }
    };
    f.getActiveCount = (id) => {
        const limitFn = pending.get(id);
        if (!limitFn) {
            return 0;
        }
        return limitFn.activeCount;
    };
    f.getPendingCount = (id) => {
        const limitFn = pending.get(id);
        if (!limitFn) {
            return 0;
        }
        return limitFn.pendingCount;
    };
    f.clear = () => {
        // note: does not cancel promises
        pending.forEach((p) => p.clearQueue());
        pending.clear();
    };
    return f;
}
exports.LimitAsyncFnByKey = LimitAsyncFnByKey;
/**
 * Execute functions in parallel, but ensure they resolve in the order they were executed
 */
function pOrderedResolve(fn) {
    const queue = p_limit_1.default(1);
    return Object.assign(async (...args) => {
        const d = Defer();
        const done = queue(() => d);
        // eslint-disable-next-line promise/catch-or-return
        await Promise.resolve(fn(...args)).then(d.resolve, d.reject);
        return done;
    }, {
        clear() {
            queue.clearQueue();
        }
    });
}
exports.pOrderedResolve = pOrderedResolve;
/**
 * Returns a function that executes with limited concurrency.
 */
function pLimitFn(fn, limit = 1) {
    const queue = p_limit_1.default(limit);
    return Object.assign((...args) => queue(() => fn(...args)), {
        clear() {
            queue.clearQueue();
        }
    });
}
exports.pLimitFn = pLimitFn;
/**
 * Only allows one outstanding call.
 * Returns same promise while task is executing.
 */
function pOne(fn) {
    let inProgress;
    return async (...args) => {
        if (inProgress) {
            return inProgress;
        }
        inProgress = (async () => {
            try {
                return await Promise.resolve(fn(...args));
            }
            finally {
                inProgress = undefined;
            }
        })();
        return inProgress;
    };
}
exports.pOne = pOne;
/**
 * Only allows calling `fn` once.
 * Returns same promise while task is executing.
 */
function pOnce(fn) {
    let inProgress;
    let started = false;
    let value;
    let error;
    return async (...args) => {
        if (!started) {
            started = true;
            inProgress = (async () => {
                try {
                    value = await Promise.resolve(fn(...args));
                }
                catch (err) {
                    error = err;
                }
                finally {
                    inProgress = undefined;
                }
            })();
        }
        if (inProgress) {
            await inProgress;
        }
        if (error) {
            throw error;
        }
        return value;
    };
}
exports.pOnce = pOnce;
class TimeoutError extends Error {
    constructor(msg = '', timeout = 0) {
        super(`The operation timed out. ${timeout}ms. ${msg}`);
        this.timeout = timeout;
        if (Error.captureStackTrace) {
            Error.captureStackTrace(this, this.constructor);
        }
    }
}
exports.TimeoutError = TimeoutError;
async function pTimeout(promise, ...args) {
    let opts = {};
    if (args[0] && typeof args[0] === 'object') {
        [opts] = args;
    }
    else {
        [opts.timeout, opts.message] = args;
    }
    const { timeout = 0, message = '', rejectOnTimeout = true } = opts;
    if (typeof timeout !== 'number') {
        throw new Error(`timeout must be a number, got ${util_1.inspect(timeout)}`);
    }
    let timedOut = false;
    const p = Defer();
    const t = setTimeout(() => {
        timedOut = true;
        if (rejectOnTimeout) {
            p.reject(new TimeoutError(message, timeout));
        }
        else {
            p.resolve(undefined);
        }
    }, timeout);
    p.catch(() => { });
    return Promise.race([
        Promise.resolve(promise).catch((err) => {
            clearTimeout(t);
            if (timedOut) {
                // ignore errors after timeout
                return;
            }
            throw err;
        }),
        p
    ]).finally(() => {
        clearTimeout(t);
        p.resolve(undefined);
    });
}
exports.pTimeout = pTimeout;
/**
 * Convert allSettled results into a thrown Aggregate error if necessary.
 */
async function allSettledValues(items, errorMessage = '') {
    const result = await Promise.allSettled(items);
    const errs = result
        .filter(({ status }) => status === 'rejected')
        .map((v) => v.reason);
    if (errs.length) {
        throw new AggregatedError_1.default(errs, errorMessage);
    }
    return result
        .map((v) => v.value);
}
exports.allSettledValues = allSettledValues;
async function sleep(ms = 0) {
    return new Promise((resolve) => {
        setTimeout(resolve, ms);
    });
}
exports.sleep = sleep;
/**
 * Wait until a condition is true
 * @param condition - wait until this callback function returns true
 * @param timeOutMs - stop waiting after that many milliseconds, -1 for disable
 * @param pollingIntervalMs - check condition between so many milliseconds
 * @param failedMsgFn - append the string return value of this getter function to the error message, if given
 * @return the (last) truthy value returned by the condition function
 */
async function until(condition, timeOutMs = 10000, pollingIntervalMs = 100, failedMsgFn) {
    // condition could as well return any instead of boolean, could be convenient
    // sometimes if waiting until a value is returned. Maybe change if such use
    // case emerges.
    const err = new Error(`Timeout after ${timeOutMs} milliseconds`);
    let isTimedOut = false;
    let t;
    if (timeOutMs > 0) {
        t = setTimeout(() => { isTimedOut = true; }, timeOutMs);
    }
    try {
        // Promise wrapped condition function works for normal functions just the same as Promises
        let wasDone = false;
        while (!wasDone && !isTimedOut) { // eslint-disable-line no-await-in-loop
            wasDone = await Promise.resolve().then(condition); // eslint-disable-line no-await-in-loop
            if (!wasDone && !isTimedOut) {
                await sleep(pollingIntervalMs); // eslint-disable-line no-await-in-loop
            }
        }
        if (isTimedOut) {
            if (failedMsgFn) {
                err.message += ` ${failedMsgFn()}`;
            }
            throw err;
        }
        return wasDone;
    }
    finally {
        clearTimeout(t);
    }
}
exports.until = until;
//# sourceMappingURL=index.js.map