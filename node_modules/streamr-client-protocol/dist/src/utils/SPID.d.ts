/**
 * SPID - Stream + Partition ID
 * See SPID constructor docs.
 *
 * SPID
 * SPIDLike
 * SID
 * SIDLike
 */
declare type RequiredKeys<T, Keys extends keyof T> = Omit<T, Keys> & Required<Pick<T, Keys>>;
/**
 * Has both streamId & partition
 */
export declare type SPIDShape = {
    streamId: string;
    streamPartition: number;
};
export declare type SPIDKeyShape = SPIDShape & {
    key: string;
};
/**
 * SPID or String representing a SPID
 * Object cases can be typechecked
 * TODO: SPID string type safety
 */
export declare type SPIDLike = string | SPIDShape;
/**
 * Must have something that looks like an id.
 * Partition optional.
 */
export declare type SID = {
    streamId: string;
    streamPartition?: number;
};
export declare type SIDLike = string | SID;
/**
 * SPID â€“ Stream + Partition ID
 * Simple Data container that represents a streamId + partition, and utilities
 * to parse various formats into a SPID.
 *
 * Use this rather than inventing new data types to represenent or parse these.
 *
 * Usage:
 * ```js
 * const spid = new SPID(streamId, streamPartition)
 * spid.id === streamId // true
 * spid.partition === streamPartition // true
 * ```
 * See tests for more usage examples.
 */
export declare class SPID implements SPIDKeyShape {
    /** stream id */
    readonly streamId: string;
    /** stream partition */
    readonly streamPartition: number;
    /** toString/fromString separator */
    protected static readonly SEPARATOR = "#";
    /** string key representing SPID */
    readonly key: string;
    /**
     * @param id - stream id
     * @param partition - stream partition
     */
    constructor(id: string, partition: number);
    /**
     * Throws if data is invalid.
     */
    private validate;
    /**
     * True iff other value is equivalent.
     */
    equals(other: SPIDLike): boolean;
    /**
     * True iff matches streamId & optionally streamPartition
     * streamId is required, hence SPIDMatcher.
     * If streamPartition is missing, just matches on streamId
     */
    matches(spidMatcher: SIDLike): boolean;
    /**
     * Convert SPIDLikePartial to SPIDObjectPartial
     * i.e. normalizes various input types/shapes to { streamId?, streamPartition? }
     * Note: does not throw on malformed input
     */
    static parse(spidLike: SPID): SPID;
    static parse(spidLike: SPIDShape): SPIDShape;
    static parse(spidLike: SIDLike): SID;
    static parse(spidLike: SPIDLike): SPIDShape;
    static parse(spidLike: Partial<SIDLike>): Partial<SPIDShape>;
    /**
     * Convert to SPID if possible, with defaults.
     * e.g.
     * ```ts
     * fromDefaults(streamId, { partition: 0 })
     * ```
     */
    static fromDefaults(spidLike: SIDLike, defaultValues?: Partial<SPIDShape>): SPID;
    static fromDefaults(spidLike: SIDLike, defaultValues: RequiredKeys<Partial<SPIDShape>, 'streamPartition'>): SPID;
    static fromDefaults(spidLike: SIDLike, defaultValues: string | RequiredKeys<Partial<SPIDShape>, 'streamPartition'>): SPID;
    static fromDefaults(spidLike: string | RequiredKeys<Partial<SPIDShape>, 'streamPartition'>, defaultValues: SIDLike): SPID;
    /**
     * Convert to SPID if possible.
     */
    static from(spidLike: SPIDLike): SPID;
    /**
     * Plain object representation of SPID id + partition
     */
    toObject(): SPIDShape;
    /**
     * String representation of SPID id + partition
     */
    toString(): string;
    /**
     * Alias of toString.
     */
    toKey(): string;
    /**
     * Returns a key for spidLike
     * e.g.
     * ```js
     * const key = SPID.toKey({ streamId, streamPartition })
     * ```
     */
    static toKey(spidLike: SPIDLike): string;
}
export {};
