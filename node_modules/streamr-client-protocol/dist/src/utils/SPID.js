"use strict";
/**
 * SPID - Stream + Partition ID
 * See SPID constructor docs.
 *
 * SPID
 * SPIDLike
 * SID
 * SIDLike
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SPID = void 0;
const util_1 = require("util");
const ValidationError_1 = __importDefault(require("../errors/ValidationError"));
class SPIDValidationError extends ValidationError_1.default {
    constructor(msg, data, ...args) {
        super((0, util_1.format)(msg, data, ...args));
        this.data = data;
    }
}
/**
 * SPID â€“ Stream + Partition ID
 * Simple Data container that represents a streamId + partition, and utilities
 * to parse various formats into a SPID.
 *
 * Use this rather than inventing new data types to represenent or parse these.
 *
 * Usage:
 * ```js
 * const spid = new SPID(streamId, streamPartition)
 * spid.id === streamId // true
 * spid.partition === streamPartition // true
 * ```
 * See tests for more usage examples.
 */
class SPID {
    /**
     * @param id - stream id
     * @param partition - stream partition
     */
    constructor(id, partition) {
        this.streamId = id;
        this.streamPartition = partition;
        this.validate();
        // static cached values to prevent unnecessary runtime allocations
        this.key = `${this.streamId}${SPID.SEPARATOR}${this.streamPartition}`;
        // prevent all mutation
        Object.freeze(this);
    }
    /**
     * Throws if data is invalid.
     */
    validate() {
        if (typeof this.streamId !== 'string' || this.streamId.length === 0) {
            throw new SPIDValidationError('SPID validation failed: id must be non-empty string: %o', {
                streamId: this.streamId,
                streamPartition: this.streamPartition
            });
        }
        if (typeof this.streamPartition !== 'number' || !Number.isSafeInteger(this.streamPartition) || this.streamPartition < 0) {
            throw new SPIDValidationError('SPID validation failed: partition must be a safe integer >= 0: %o', {
                streamId: this.streamId,
                streamPartition: this.streamPartition
            });
        }
    }
    /**
     * True iff other value is equivalent.
     */
    equals(other) {
        // check if same instance
        if (other === this) {
            return true;
        }
        let otherSpid;
        try {
            otherSpid = SPID.from(other);
        }
        catch (_err) {
            // ignore error
            // not equal if not valid
            return false;
        }
        // check key matches
        return this.key === otherSpid.key;
    }
    /**
     * True iff matches streamId & optionally streamPartition
     * streamId is required, hence SPIDMatcher.
     * If streamPartition is missing, just matches on streamId
     */
    matches(spidMatcher) {
        if (spidMatcher instanceof SPID) {
            return this.equals(spidMatcher);
        }
        const { streamId, streamPartition } = SPID.parse(spidMatcher);
        if (streamPartition == null) {
            return this.streamId === streamId;
        }
        return this.streamId === streamId && this.streamPartition === streamPartition;
    }
    static parse(spidLike) {
        var _a;
        if (spidLike instanceof SPID) {
            return spidLike;
        }
        // convert from string
        if (typeof spidLike === 'string') {
            const [streamId, partitionStr] = spidLike.split(this.SEPARATOR);
            // partition is optional, falls back to undefined i.e. default
            const streamPartition = partitionStr != null ? Number.parseFloat(partitionStr) : undefined;
            return { streamId, streamPartition };
        }
        else if (spidLike && typeof spidLike === 'object') {
            const streamId = spidLike.streamId;
            const partition = (_a = spidLike.streamPartition) !== null && _a !== void 0 ? _a : undefined;
            // try parse if a value was passed, but fall back to undefined i.e. default
            const streamPartition = typeof partition === 'string' ? Number.parseFloat(partition) : partition;
            return { streamId, streamPartition };
        }
        else {
            return { streamId: undefined, streamPartition: undefined };
        }
    }
    static fromDefaults(spidLike, defaultValues) {
        // return spid if already spid
        if (spidLike instanceof SPID) {
            return spidLike;
        }
        // defaults can be partial, e.g. { partition: 0 }
        // toSPIDObjectPartial can handle undefined input but we want external interface to check for it.
        const defaults = SPID.parse(defaultValues);
        const { streamId = defaults === null || defaults === void 0 ? void 0 : defaults.streamId, streamPartition = defaults === null || defaults === void 0 ? void 0 : defaults.streamPartition } = SPID.parse(spidLike);
        try {
            // constructor can handle partial input but we want external interface to check for it.
            return new SPID(streamId, streamPartition);
        }
        catch (err) {
            // TODO: add more conversions?
            throw new SPIDValidationError(`SPID validation failed, input is malformed. ${err && err.message} %o`, spidLike);
        }
    }
    /**
     * Convert to SPID if possible.
     */
    static from(spidLike) {
        return SPID.fromDefaults(spidLike);
    }
    /**
     * Plain object representation of SPID id + partition
     */
    toObject() {
        return {
            streamId: this.streamId,
            streamPartition: this.streamPartition,
        };
    }
    /**
     * String representation of SPID id + partition
     */
    toString() {
        return this.key;
    }
    /**
     * Alias of toString.
     */
    toKey() {
        return this.toString();
    }
    /**
     * Returns a key for spidLike
     * e.g.
     * ```js
     * const key = SPID.toKey({ streamId, streamPartition })
     * ```
     */
    static toKey(spidLike) {
        return SPID.from(spidLike).key;
    }
}
exports.SPID = SPID;
/** toString/fromString separator */
SPID.SEPARATOR = '#';
//# sourceMappingURL=SPID.js.map