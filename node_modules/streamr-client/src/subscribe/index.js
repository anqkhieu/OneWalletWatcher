"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Subscriber = exports.Subscription = void 0;
const utils_1 = require("../utils");
const iterators_1 = require("../utils/iterators");
const utils_2 = require("../stream/utils");
const messageStream_1 = __importDefault(require("./messageStream"));
const resendStream_1 = __importDefault(require("./resendStream"));
const Subscription_1 = __importDefault(require("./Subscription"));
exports.Subscription = Subscription_1.default;
const Subscriptions_1 = __importDefault(require("./Subscriptions"));
/**
 * Top-level user-facing interface for creating/destroying subscriptions.
 */
class Subscriber {
    constructor(client) {
        this.client = client;
        this.subscriptions = new Subscriptions_1.default(client);
    }
    getSubscriptionSession(...args) {
        // @ts-expect-error
        return this.subscriptions.getSubscriptionSession(...args);
    }
    get(opts) {
        return this.subscriptions.get(opts);
    }
    getAll() {
        return this.subscriptions.getAll();
    }
    count(options) {
        return this.subscriptions.count(options);
    }
    async subscribe(opts, onFinally) {
        return this.subscriptions.add(opts, onFinally);
    }
    async unsubscribeAll() {
        return this.subscriptions.removeAll();
    }
    async stop() {
        await this.unsubscribeAll();
    }
    async unsubscribe(options) {
        if (options instanceof Subscription_1.default) {
            const sub = options;
            return sub.cancel();
        }
        // @ts-expect-error
        if (options && options.options) {
            // @ts-expect-error
            return this.unsubscribe(options.options);
        }
        // @ts-expect-error
        return this.subscriptions.removeAll(options);
    }
    async resend(opts) {
        const resendMsgStream = resendStream_1.default(this.client, opts);
        const sub = new Subscription_1.default(this.client, {
            msgStream: resendMsgStream,
            ...opts,
        }, async (...args) => {
            sub.emit('resent');
            await sub.cancel(...args);
        });
        await resendMsgStream.subscribe().catch(async (err) => {
            await sub.cancel();
            throw err;
        });
        return sub;
    }
    async resendSubscribe(opts, onFinally) {
        const onEndFns = [];
        // This works by passing a custom message stream to a subscription
        // the custom message stream iterates resends, then iterates realtime
        const options = utils_2.validateOptions(opts);
        const resendMessageStream = resendStream_1.default(this.client, options);
        onEndFns.push(async () => resendMessageStream.cancel());
        // @ts-expect-error
        const realtimeMessageStream = messageStream_1.default(this.client.connection, options);
        onEndFns.push(async () => realtimeMessageStream.cancel());
        // cancel both streams on end
        async function end(optionalErr) {
            const tasks = onEndFns.slice().reverse();
            onEndFns.length = 0;
            await tasks.reduce((prev, next) => (prev.finally(async () => next())), Promise.resolve());
            if (optionalErr) {
                throw optionalErr;
            }
        }
        let resendSubscribeSub;
        let lastResentMsgId;
        let lastProcessedMsgId;
        const resendDone = utils_1.Defer();
        let isResendDone = false;
        let resentEmitted = false;
        onEndFns.push(() => resendDone.resolve(undefined));
        function messageIDString(msg) {
            return msg.getMessageID().serialize();
        }
        function maybeEmitResend() {
            if (resentEmitted || !isResendDone) {
                return;
            }
            // need to account for both cases:
            // resent finished after last message got through pipeline
            // resent finished before last message got through pipeline
            if (!lastResentMsgId || lastProcessedMsgId === lastResentMsgId) {
                lastResentMsgId = undefined;
                resentEmitted = true;
                resendSubscribeSub.emit('resent');
            }
        }
        const it = iterators_1.pipeline([
            async function* HandleResends() {
                // Inconvience here
                // emitting the resent event is a bit tricky in this setup because the subscription
                // doesn't know anything about the source of the messages
                // can't emit resent immediately after resent stream end since
                // the message is not yet through the message pipeline
                let currentMsgId;
                try {
                    for await (const msg of resendSubscribeSub.resend) {
                        currentMsgId = messageIDString(msg.streamMessage);
                        yield msg;
                    }
                }
                finally {
                    lastResentMsgId = currentMsgId;
                    isResendDone = true;
                    maybeEmitResend();
                    // @ts-expect-error
                    resendDone.resolve();
                }
            },
            async function* ResendThenRealtime(src) {
                yield* src;
                await resendDone; // ensure realtime doesn't start until resend ends
                yield* resendSubscribeSub.realtime;
            },
        ], end);
        onEndFns.push(async () => it.cancel());
        const resendTask = resendMessageStream.subscribe().catch(async (err) => {
            await resendMessageStream.cancel(err);
        });
        const realtimeTask = this.subscribe({
            ...options,
            // @ts-expect-error
            msgStream: it,
            afterSteps: [
                async function* detectEndOfResend(src) {
                    for await (const msg of src) {
                        const id = messageIDString(msg);
                        try {
                            yield msg;
                        }
                        finally {
                            lastProcessedMsgId = id;
                            maybeEmitResend();
                        }
                    }
                },
            ],
        }, onFinally).then((sub) => {
            resendSubscribeSub = sub;
            onEndFns.push(async () => {
                if (!resendSubscribeSub.isCancelled()) {
                    await resendSubscribeSub.cancel();
                }
            });
            return sub;
        });
        const tasks = [
            realtimeTask,
            resendTask,
        ];
        try {
            await Promise.allSettled(tasks);
            await Promise.all(tasks);
        }
        catch (err) {
            await end();
            throw err;
        }
        // attach additional utility functions
        return Object.assign(resendSubscribeSub, {
            realtime: realtimeMessageStream,
            resend: resendMessageStream,
        });
    }
}
exports.Subscriber = Subscriber;
//# sourceMappingURL=index.js.map