"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const events_1 = __importDefault(require("events"));
const utils_1 = require("../utils");
const utils_2 = require("../stream/utils");
const pipeline_1 = __importDefault(require("./pipeline"));
const Validator_1 = __importDefault(require("./Validator"));
async function defaultOnFinally(err) {
    if (err) {
        throw err;
    }
}
/**
 * @category Important
 */
class Subscription extends events_1.default {
    constructor(client, opts, onFinally = defaultOnFinally) {
        super();
        /** @internal */
        this.iterated = false;
        this.client = client;
        this.options = utils_2.validateOptions(opts);
        this.key = this.options.key;
        this.id = utils_1.counterId(`Subscription:${this.options.id || ''}${this.key}`);
        this.debug = client.debug.extend(this.id);
        this.debug('create');
        this.streamId = this.options.streamId;
        this.streamPartition = this.options.streamPartition;
        this._onDone = utils_1.Defer();
        this._onDone.catch(() => { }); // prevent unhandledrejection
        this._onFinally = onFinally;
        const validate = opts.validate || Validator_1.default(client, this.options);
        this.onPipelineEnd = this.onPipelineEnd.bind(this);
        this.pipeline = opts.pipeline || pipeline_1.default(client, {
            ...this.options,
            validate,
            onError: (err) => {
                this.emit('error', err);
            },
        }, this.onPipelineEnd);
        this.msgStream = this.pipeline.msgStream;
    }
    emit(event, ...args) {
        if (event !== 'error') {
            return super.emit(event, ...args);
        }
        const [error] = args;
        if (!this.listenerCount('error')) {
            this.debug('emitting error but no error listeners, cancelling subscription', error);
            this.cancel(error);
            return false;
        }
        try {
            this.debug('emit error', error);
            return super.emit('error', ...args);
        }
        catch (err) {
            if (err !== error) {
                this.debug('error emitting error!', err);
            }
            this.cancel(err);
            return false;
        }
    }
    /**
     * Expose cleanup
     * @internal
     */
    async onPipelineEnd(err) {
        this.debug('onPipelineEnd', err);
        let error = err;
        this.pipeline = undefined;
        try {
            const onFinally = this._onFinally;
            this._onFinally = () => { };
            await onFinally(error);
        }
        catch (onFinallyError) {
            error = utils_1.AggregatedError.from(error, onFinallyError);
        }
        finally {
            this._onDone.handleErrBack(error);
        }
    }
    // eslint-disable-next-line class-methods-use-this
    count() {
        // will be overridden by subscriptions
        return 1;
    }
    /** @internal */
    async onDone() {
        return this._onDone;
    }
    /**
     * Collect all messages into an array.
     * Returns array when subscription is ended.
     */
    async collect(n) {
        const msgs = [];
        for await (const msg of this) {
            if (n === 0) {
                break;
            }
            msgs.push(msg.getParsedContent());
            if (msgs.length === n) {
                break;
            }
        }
        return msgs;
    }
    [Symbol.asyncIterator]() {
        // only iterate sub once
        if (this.iterated) {
            throw new Error('cannot iterate subscription more than once. Cannot iterate if message handler function was passed to subscribe.');
        }
        this.iterated = true;
        if (!this.pipeline) {
            // subscription is done
            // eslint-disable-next-line require-yield
            return (function* Noop() {
                return undefined;
            }());
        }
        return this.pipeline;
    }
    async cancel(...args) {
        var _a;
        return (_a = this.pipeline) === null || _a === void 0 ? void 0 : _a.cancel(...args);
    }
    async end(...args) {
        var _a;
        return (_a = this.pipeline) === null || _a === void 0 ? void 0 : _a.end(...args);
    }
    isCancelled(...args) {
        if (!this.pipeline) {
            return false;
        }
        return this.pipeline.isCancelled(...args);
    }
    async return(...args) {
        var _a;
        return (_a = this.pipeline) === null || _a === void 0 ? void 0 : _a.return(...args);
    }
    async throw(...args) {
        var _a;
        return (_a = this.pipeline) === null || _a === void 0 ? void 0 : _a.throw(...args);
    }
    /**
     * Remove this subscription from the stream.
     */
    async unsubscribe() {
        return this.cancel();
    }
}
exports.default = Subscription;
//# sourceMappingURL=Subscription.js.map