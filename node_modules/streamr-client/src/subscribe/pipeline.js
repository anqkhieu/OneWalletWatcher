"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SignatureRequiredError = void 0;
const utils_1 = require("../utils");
const iterators_1 = require("../utils/iterators");
const utils_2 = require("../stream/utils");
const Validator_1 = __importDefault(require("./Validator"));
const messageStream_1 = __importDefault(require("./messageStream"));
const OrderMessages_1 = __importDefault(require("./OrderMessages"));
const Decrypt_1 = __importDefault(require("./Decrypt"));
var Validator_2 = require("./Validator");
Object.defineProperty(exports, "SignatureRequiredError", { enumerable: true, get: function () { return Validator_2.SignatureRequiredError; } });
async function collect(src) {
    const msgs = [];
    for await (const msg of src) {
        msgs.push(msg.getParsedContent());
    }
    return msgs;
}
/**
 * Subscription message processing pipeline
 */
function MessagePipeline(client, opts = {}, onFinally = async (err) => { if (err) {
    throw err;
} }) {
    const options = utils_2.validateOptions(opts);
    const { key, afterSteps = [], beforeSteps = [] } = options;
    const id = utils_1.counterId('MessagePipeline') + key;
    /* eslint-disable object-curly-newline */
    const { validate = Validator_1.default(client, options), msgStream = messageStream_1.default(client.connection, options), orderingUtil = OrderMessages_1.default(client, options), decrypt = Decrypt_1.default(client, options), } = options;
    /* eslint-enable object-curly-newline */
    const seenErrors = new WeakSet();
    const onErrorFn = options.onError ? options.onError : (error) => { throw error; };
    const onError = async (err) => {
        // don't handle same error multiple times
        if (seenErrors.has(err)) {
            return;
        }
        seenErrors.add(err);
        await onErrorFn(err);
    };
    // re-order messages (ignore gaps)
    const internalOrderingUtil = OrderMessages_1.default(client, {
        ...options,
        gapFill: false,
    });
    // collect messages that fail validation/parsing, do not push out of pipeline
    // NOTE: we let failed messages be processed and only removed at end so they don't
    // end up acting as gaps that we repeatedly try to fill.
    const ignoreMessages = new WeakSet();
    const p = iterators_1.pipeline([
        // take messages
        msgStream,
        // custom pipeline steps
        ...beforeSteps,
        // unpack stream message
        async function* getStreamMessage(src) {
            for await (const { streamMessage } of src) {
                yield streamMessage;
            }
        },
        // order messages (fill gaps)
        orderingUtil,
        // validate
        async function* ValidateMessages(src) {
            for await (const streamMessage of src) {
                try {
                    await validate(streamMessage);
                }
                catch (err) {
                    ignoreMessages.add(streamMessage);
                    await onError(err);
                }
                yield streamMessage;
            }
        },
        // decrypt
        async function* DecryptMessages(src) {
            yield* decrypt(src, async (err, streamMessage) => {
                ignoreMessages.add(streamMessage);
                await onError(err);
            });
        },
        // parse content
        async function* ParseMessages(src) {
            for await (const streamMessage of src) {
                try {
                    streamMessage.getParsedContent();
                }
                catch (err) {
                    ignoreMessages.add(streamMessage);
                    await onError(err);
                }
                yield streamMessage;
            }
        },
        // re-order messages (ignore gaps)
        internalOrderingUtil,
        // ignore any failed messages
        async function* IgnoreMessages(src) {
            for await (const streamMessage of src) {
                if (ignoreMessages.has(streamMessage)) {
                    continue;
                }
                yield streamMessage;
            }
        },
        // special handling for bye message
        async function* ByeMessageSpecialHandling(src) {
            for await (const orderedMessage of src) {
                yield orderedMessage;
                try {
                    if (orderedMessage.isByeMessage()) {
                        break;
                    }
                }
                catch (err) {
                    await onError(err);
                }
            }
        },
        // custom pipeline steps
        ...afterSteps
    ], async (err, ...args) => {
        decrypt.stop();
        await msgStream.cancel(err);
        try {
            if (err) {
                await onError(err);
            }
        }
        finally {
            await onFinally(err, ...args);
        }
    });
    return Object.assign(p, {
        id,
        msgStream,
        orderingUtil,
        validate,
        collect: collect.bind(null, p),
        end: msgStream.end,
    });
}
exports.default = MessagePipeline;
//# sourceMappingURL=pipeline.js.map